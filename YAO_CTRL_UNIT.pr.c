/* Process model C form file: YAO_CTRL_UNIT.pr.c */
/* Portions of this file copyright 1986-2012 by OPNET Technologies, Inc. */


/*
 =========================== NOTE ==========================
 This file is automatically generated from YAO_CTRL_UNIT.pr.m
 during a process model compilation.

 Do NOT manually edit this file.
 Manual edits will be lost during the next compilation.
 =========================== NOTE ==========================
*/



/* This variable carries the header into the object file */
const char YAO_CTRL_UNIT_pr_c [] = "MIL_3_Tfile_Hdr_ 171A 30A modeler 7 59197BFD 59197BFD 1 WINDOWS-4K8LM8B MyPC 0 0 none none 0 0 none 0 0 0 0 0 0 0 0 2b74 2                                                                                                                                                                                                                                                                                                                                                                                                     ";
#include <string.h>



/* OPNET system definitions */
#include <opnet.h>



/* Header Block */

#include <stdlib.h> //atoi
#include <math.h> //pow, sqrt
#include <time.h> //time()
#include "..\include\Yao_header.h"

//intrpt code
#define 	DEFAULT_STRATEGY_CODE		51
#define		INFO_DISPLAY_CODE			53
#define 	UPDATE_STRATEGY_CODE		55
//#define 	UPDATE_NEIGHBOUR_CODE		57
#define 	UPDATE_FLOW_CODE			59
#define 	CNC_CODE			61
#define 	HELLO_CODE			63
#define     REMOTE_TIME_CODE    65

//pkt stream
#define OUTPUT_STRM		0
#define INPUT_STRM		0

/*define the transation conditions*/
#define REMOTE_INTRPT	(op_intrpt_type() == OPC_INTRPT_REMOTE )
//#define SELF_INTRPT	(op_intrpt_type() == OPC_INTRPT_SELF )
#define REMOTE_TIME_INTRPT		(op_intrpt_type() == OPC_INTRPT_REMOTE && op_intrpt_code () == REMOTE_TIME_CODE)
//#define REMOTE_UPDATE_FLOW_INTRPT	(op_intrpt_type() == OPC_INTRPT_REMOTE && op_intrpt_code () == REMOTE_UPDATE_FLOW_CODE)
#define DEFAULT_STRATEGY_INTRPT	(op_intrpt_type() == OPC_INTRPT_SELF && op_intrpt_code () == DEFAULT_STRATEGY_CODE)
#define INFO_DISPLAY_INTRPT (op_intrpt_type() == OPC_INTRPT_SELF && op_intrpt_code () == INFO_DISPLAY_CODE)
//#define UPDATE_STRATEGY_INTRPT	(op_intrpt_type() == OPC_INTRPT_SELF && op_intrpt_code () == UPDATE_STRATEGY_CODE)
//#define UPDATE_NEIGHBOUR_INTRPT	(op_intrpt_type() == OPC_INTRPT_SELF && op_intrpt_code () == UPDATE_NEIGHBOUR_CODE)
#define UPDATE_FLOW_INTRPT	(op_intrpt_type() == OPC_INTRPT_SELF && op_intrpt_code () == UPDATE_FLOW_CODE)
#define CNC_INTRPT	(op_intrpt_type() == OPC_INTRPT_SELF && op_intrpt_code () == CNC_CODE)
#define HELLO_INTRPT	(op_intrpt_type() == OPC_INTRPT_SELF && op_intrpt_code () == HELLO_CODE)
#define PKT_ARRIVE	op_intrpt_type() == OPC_INTRPT_STRM

//Condition Indicating Flag
#define UNMATCHED_FLAG 0
#define MATCHED_FLAG 1
//Conditon Field Label
#define TOLERANCE_FIELD 1
//Conditon Field SubLabel
#define DELAY_SUBFIELD 1
//Value Type Label
//#define BOOLEAN_VALUE_LABEL 1
//Port Label
#define DEFAULT_PORT 0
#define GOSSIP_PORT 1
#define GUO_PORT 2
//Nexthop Category
#define DEFAULT_NC 0
#define ANY_NC 1
#define SHORTPATH_NC 2
#define GUO_NC 3
//Forwarding Pattern
#define BROADCAST_FP 0
#define UNICAST_FP 1

//number of fixed nodes and mobile nodes
#define FN_NUM 50
#define MN_NUM 5

#define vc 3e8

typedef struct NexthopCategory
{
	int		categoryLabel;
	List*	node_list;
}NexthopCategory;

typedef struct ForwardingPara
{
	List*	nexthopCandidate_list;
}ForwardingPara;

typedef struct Port
{
	int portLabel;
	List* categoryLabel_list;
	int candidateMaxNum; //max number of nodes to be selected
	int forwardingPattern;
}Port;

typedef struct ConditionField
{
	int fieldLabel;
	//int valueTypeLabel;
	List* definedCondition_list;
	List* realCondition_list;

}ConditionField;

typedef struct IntValueRange
{
	int highBound;
	int lowBound;
}IntValueRange;

typedef struct TargetCondition
{
	int		fieldLabel;
	List*	subfieldLabel_list;
}TargetCondition;

typedef struct NeighbourMaintainanceEntry
{
	int		node;
	double	time;
	int neighbourNum;
	double sinkHelloRatio;
}NeighbourMaintainanceEntry;

typedef struct Pkt4SR //buffered packet for secondary receivers
{
	List*	secondaryReceivers_list;
	Packet*	pkt_ptr;
}Pkt4SR;


/* End of Header Block */

#if !defined (VOSD_NO_FIN)
#undef	BIN
#undef	BOUT
#define	BIN		FIN_LOCAL_FIELD(_op_last_line_passed) = __LINE__ - _op_block_origin;
#define	BOUT	BIN
#define	BINIT	FIN_LOCAL_FIELD(_op_last_line_passed) = 0; _op_block_origin = __LINE__;
#else
#define	BINIT
#endif /* #if !defined (VOSD_NO_FIN) */



/* State variable definitions */
typedef struct
	{
	/* Internal state tracking for FSM */
	FSM_SYS_STATE
	/* State Variables */
	Objid	                  		my_objid                                        ;
	Objid	                  		my_node_id                                      ;
	Objid	                  		dataPlane_objid                                 ;
	List*	                  		neighbour_list                                  ;
	List*	                  		nexthopCategory_list                            ;
	List*	                  		C2PME_list                                      ;
	List*	                  		port_list                                       ;
	List*	                  		conditionField_list                             ;
	int	                    		my_node_addr                                    ;	/* node IP address */
	int	                    		seq_num                                         ;
	Stathandle	             		ctrl_ete_delay_global                           ;
	List*	                  		neighbour_maintainance_list                     ;
	List*	                  		pkt4SR_list                                     ;
	int	                    		sink_hello_num                                  ;
	int	                    		num_absorb_node                                 ;
	Objid	                  		sink_objid                                      ;
	double	                 		r_distance                                      ;
	double	                 		successrate                                     ;
	double	                 		recv_time                                       ;
	int	                    		userighthand                                    ;
	double	                 		dist_neigh_to_sour                              ;
	int	                    		no_seq                                          ;
	} YAO_CTRL_UNIT_state;

#define my_objid                		op_sv_ptr->my_objid
#define my_node_id              		op_sv_ptr->my_node_id
#define dataPlane_objid         		op_sv_ptr->dataPlane_objid
#define neighbour_list          		op_sv_ptr->neighbour_list
#define nexthopCategory_list    		op_sv_ptr->nexthopCategory_list
#define C2PME_list              		op_sv_ptr->C2PME_list
#define port_list               		op_sv_ptr->port_list
#define conditionField_list     		op_sv_ptr->conditionField_list
#define my_node_addr            		op_sv_ptr->my_node_addr
#define seq_num                 		op_sv_ptr->seq_num
#define ctrl_ete_delay_global   		op_sv_ptr->ctrl_ete_delay_global
#define neighbour_maintainance_list		op_sv_ptr->neighbour_maintainance_list
#define pkt4SR_list             		op_sv_ptr->pkt4SR_list
#define sink_hello_num          		op_sv_ptr->sink_hello_num
#define num_absorb_node         		op_sv_ptr->num_absorb_node
#define sink_objid              		op_sv_ptr->sink_objid
#define r_distance              		op_sv_ptr->r_distance
#define successrate             		op_sv_ptr->successrate
#define recv_time               		op_sv_ptr->recv_time
#define userighthand            		op_sv_ptr->userighthand
#define dist_neigh_to_sour      		op_sv_ptr->dist_neigh_to_sour
#define no_seq                  		op_sv_ptr->no_seq

/* These macro definitions will define a local variable called	*/
/* "op_sv_ptr" in each function containing a FIN statement.	*/
/* This variable points to the state variable data structure,	*/
/* and can be used from a C debugger to display their values.	*/
#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE
#define FIN_PREAMBLE_DEC	YAO_CTRL_UNIT_state *op_sv_ptr;
#define FIN_PREAMBLE_CODE	\
		op_sv_ptr = ((YAO_CTRL_UNIT_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr));


/* Function Block */

#if !defined (VOSD_NO_FIN)
enum { _op_block_origin = __LINE__ + 2};
#endif



/****Tools************************/
/*get node addr*/
int get_sufix_from_name_IP_COPY__YAO_CTRL_PLANE(char* str_ptr)
{
	int		i,j;
	char	id_str[8];
	int		node_id;
	FIN(get_sufix_from_name_IP_COPY__YAO_CTRL_PLANE(char* str_ptr));
	i = 5;j = 0;
	while(*(str_ptr+i) != '\0')
		{
		id_str[j] = *(str_ptr+i); 
		i++;
		j++;
		}
	id_str[j] = '\0';
	node_id = atoi(id_str);
	FRET (node_id);
}

/*Remove a integer number in a list if exist*/
Boolean remove_intnum(int num, List* list)
{
	int		i;
	int*	int_ptr;
	Boolean has_it;
	
	FIN(Boolean remove_intnum(int num, List* list));
	
	has_it = OPC_FALSE;
	
	for (i=0; i<op_prg_list_size(list); ++i)
	{
		if (num == *(int*)op_prg_list_access(list, i))
		{
			int_ptr = (int*)op_prg_list_remove(list, i);
			op_prg_mem_free(int_ptr);
			has_it = OPC_TRUE;
			break;
		}
	}
	
	FRET (has_it);
}

/*whether exist a integer number in a list*/
Boolean exist_intnum(int num, List* list)
{
	int		i;
	Boolean has_it;
	
	FIN(exist_intnum(int num, List* list));
	
	has_it = OPC_FALSE;
	
	for (i=0; i<op_prg_list_size(list); ++i)
	{
		if (num == *(int*)op_prg_list_access(list, i))
		{
			has_it = OPC_TRUE;
			break;
		}
	}
	
	FRET (has_it);
}

double Bubble_Sort(List *list)
{
    double m,n;
	int i;
	FIN(  Bubble_Sort(List *list) );
	n = *(double*) op_prg_list_access(list, 0);
    for(i=1;i<op_prg_list_size(list);i++)
    {
		m = *(double *) op_prg_list_access(list, i);
            if(m > n)
            {
                int temp = n;
                n = m;
				m = temp;
            }
     }
   FRET (n);
}

int Select_index_target(List *list, double n)
{
int i;
FIN(Select_index_target(List *list, double n);)
for(i=0;i<op_prg_list_size(list);i++)
 {
   if(n == *(double *)op_prg_list_access(list,i))
	   {
	     FRET(i);
	   }
 }
 FRET(-1);
}

int Select_index_target_int(List *list, int n)
{
int i;
FIN(Select_index_target(List *list, int n);)
for(i=0;i<op_prg_list_size(list);i++)
 {
   if(n == *(int *)op_prg_list_access(list,i))
	   {
	     FRET(i);
	   }
 }
 FRET(-1);
}


int Select_neighbour_node(List *neigh_list,double Totalpower,List *dist_list,double Totaldis, List *angle_list,List *numNeigh_list,int totalNumNeigh)
{
int i,low_index=0,elected_node,neighbour,NumNeigh;//high_index;
double factor,a,distance,*p,angle,max_p,power,absorb,delay,move_time=0,neigh_x_position,neigh_y_position;
char *temp_name,temp_neighbour[3];
Objid neighId;
List *prob_list;
int whether_harvest,mobile;
FIN( Select_neighbour_node(List *neigh_list,double Totalpower,List *dist_list,double Totaldis, List *angle_list,List *numNeigh_list,int totalNumNeigh));


if(op_prg_list_size(neigh_list)>1)
{
	 prob_list=op_prg_list_create();
for(i=0;i<op_prg_list_size(neigh_list);i++)
	{
		neighbour = *(int *)op_prg_mem_alloc(sizeof(int));
		distance = *(double *)op_prg_mem_alloc(sizeof(double));
		angle = *(double *)op_prg_mem_alloc(sizeof(double));
		NumNeigh = *(int *)op_prg_mem_alloc(sizeof(int));
		neighbour = *(int *) op_prg_list_access(neigh_list,i);
       // printf("nexthop may be %d\n",neighbour);
	    itoa(neighbour,temp_neighbour,10);				
	    temp_name=(char *)op_prg_mem_alloc(sizeof("top.Campus Network.node_"));
	    strcpy(temp_name,"top.Campus Network.node_");
        strcat(temp_name,temp_neighbour);
		//printf("name is %s\n",temp_name);
	    neighId=op_id_from_hierarchical_name(temp_name);
		op_ima_obj_attr_get(neighId,"Residual_energy",&power);   
		op_ima_obj_attr_get (neighId, "Whether_harvest", &whether_harvest);
		op_ima_obj_attr_get(neighId,"E_absorption_ability", &absorb);
		op_ima_obj_attr_get(neighId,"Mobile", &mobile);	
	    op_ima_obj_attr_get(neighId,"x position", &neigh_x_position);
        op_ima_obj_attr_get(neighId,"y position", &neigh_y_position);
		/*reference*/
		if(mobile==1)
			{
			if(op_prg_list_size(neigh_list)>1)
		    {
			op_prg_list_remove(neigh_list,i);
			continue;
			}
			}
		/*else
			move_time=dist_neigh_to_sour/vc;*/
		
		//guo
	
		/*	if(mobile==1)
			{
	         if(neigh_x_position<27)
	           min_d=27-neigh_x_position;
	         else if(neigh_x_position>920)
	           min_d=neigh_x_position-920;
	         else if(neigh_y_position>647)
	                  min_d=neigh_y_position-647;
	         else if(neigh_y_position>22)
	          min_d=neigh_y_position-22;
	         else
	         min_d=22-neigh_y_position;
		     	move_time=	min_d/vc;
			}
		else
			move_time=dist_neigh_to_sour/vc;*/
		
		
		
		//delay=op_sim_time()-recv_time+move_time;
	//	printf("move_time is %f,delay is %f\n",move_time,delay);
		if(whether_harvest==1)
		num_absorb_node=1;
		else
			{
			absorb=0;
			num_absorb_node=0;
			}
		//printf("power is %f, harvest node is %d\n",power,num_absorb_node);
		distance= *(double *)op_prg_list_access(dist_list, i);
		angle= *(double *)op_prg_list_access(angle_list, i);
		NumNeigh=*(int *)op_prg_list_access(numNeigh_list, i);
		
		//printf("totalNumNeigh is %d\n",totalNumNeigh);
		p = (double *)op_prg_mem_alloc(sizeof(double));
		a= pow((num_absorb_node+1),(1+absorb));
		
		/*guo*/
		factor=pow(mobile+2,(280.0-op_sim_time()+(10.0+no_seq))/280.0-0.2);
		//printf("ggg is %f\n",factor);
	   // *p=(a*power/Totalpower)*(1-(distance/Totaldis))*cos(angle)*((double)NumNeigh/(double)totalNumNeigh)*factor;
			
		/*reference*/
         *p=(a*power/Totalpower)*(1-(distance/Totaldis))*cos(angle)*((double)NumNeigh/(double)totalNumNeigh);
	//	printf("possibility is %f\n",*p);
			//if(whether_harvest!=0)
			//*p
		op_prg_list_insert(prob_list,p,OPC_LISTPOS_TAIL);
     }
if(op_prg_list_size(prob_list)>0)
{
  max_p=Bubble_Sort(prob_list);

//printf("max_p is %f\n",max_p);
  low_index=Select_index_target(prob_list,max_p);
//printf("index of selecting is %d\n",low_index);
  op_prg_mem_free(temp_name);
  op_prg_mem_free(p);
  }
}
if(op_prg_list_size(neigh_list)==0)
 {FRET(0);}
elected_node=*(int *)op_prg_mem_alloc(sizeof(int));
elected_node=*(int *)op_prg_list_access(neigh_list,low_index);
//printf("elected node is %d\n",elected_node);
 FRET (elected_node);
}

int gets_ip_address_from_name_mac(char* node_name)
	{
		int i;
		int j;
		char id_str[8];
		int ip_address;
		FIN(gets_ip_address_from_name_mac(char* node_name));
		i=5;
		j=0;
		while(*(node_name+i) != '\0')
			{
				id_str[j] = *(node_name+i);
				i++;
				j++;
			}
		id_str[j] = '\0';
		ip_address = atoi(id_str);
		FRET (ip_address);
	}

/*
算法：
	获取目的节点和邻区节点的坐标	
op_ima_obj_pos_get(my_objid,&latitude,&longitude,&altiude,&x_pos,&y_pos,&z_pos)
	获取邻区节点表(neighbour_list)
    
	根据邻区节点和传输半径画出forward region
     
    筛选出forward region里的邻区节点 并存在表里

	等面积分隔子区域

    算子区域的能量

	计算概率
	选择的邻区放在guo_nc且永远保持有一个点在list里面

		*/

List* routestrate()
{
double my_y_position_now,my_x_position_now,destination_x_position,destination_y_position,neigh_x_position,neigh_y_position,r1_power=0,r2_power=0,r3_power=0,r4_power=0,power;
double beta,*theta=0,r_dist,*dist_neigh_to_sink,r1_averpower=0,r2_averpower=0,r3_averpower=0,r4_averpower=0,totaldist_1=0,totaldist_2=0,totaldist_3=0,totaldist_4=0,n;
int mobile,low_index=0,r_trans,i,NC,*neighbour,*int_ptr,*numNeigh,r1_totalNumNeigh=0,r2_totalNumNeigh=0,r3_totalNumNeigh=0,r4_totalNumNeigh=0;
List *neighcond_1,*neighcond_2,*neighcond_3,*neighcond_4,*powerlist,*dislist1,*dislist2,*dislist3,*dislist4,*angle,*angle1,*angle2,*angle3,*angle4,*result_list,*numNeigh1,*numNeigh2,*numNeigh3,*numNeigh4;
char temp_neighbour[3],*temp_name;
Objid neighId; 
NeighbourMaintainanceEntry* nei_entry=OPC_NIL;
char path[32];

FIN(routestrate());
dist_neigh_to_sour=0;
mobile=0;
//获取源节点和目的节点坐标
op_ima_obj_attr_get(my_node_id,"x position", &my_x_position_now);
op_ima_obj_attr_get(my_node_id,"y position", &my_y_position_now);
op_ima_obj_attr_get(my_node_id,"Mobile", &mobile);	
sink_objid=op_id_from_hierarchical_name("top.Campus Network.node_3");
op_ima_obj_attr_get(sink_objid,"x position", &destination_x_position);
op_ima_obj_attr_get(sink_objid,"y position", &destination_y_position);
op_ima_obj_attr_get(my_node_id,"trajectory", path);
/*printf("current x is %f\n",my_x_position_now);
printf("current y is %f\n",my_y_position_now);
printf("destination x is %f\n",destination_x_position);
printf("destination y is %f\n",destination_y_position);*/

//获取源节点的发送半径
//op_ima_obj_attr_get(my_objid,"",&r_trans)
//获取源节点与终点节点连线的半径
r_trans=75;
NC=0;
num_absorb_node=0;
r_dist=sqrt((my_x_position_now-destination_x_position)*(my_x_position_now-destination_x_position)+(my_y_position_now-destination_y_position)*(my_y_position_now-destination_y_position));
//printf("rdistance is %f\n",r_dist);
beta=2*acos(r_trans/(2*r_dist));
//printf("beta is %f\n",beta);
//printf("At present the node is %2d\n",my_node_addr);
	 neighcond_1 = op_prg_list_create();
	 neighcond_2 = op_prg_list_create();
	 neighcond_3 = op_prg_list_create();
	 neighcond_4 = op_prg_list_create();
	 dislist1=op_prg_list_create();
	 dislist2=op_prg_list_create();
	 dislist3=op_prg_list_create();
	 dislist4=op_prg_list_create();
	 angle1=op_prg_list_create();
	 angle2=op_prg_list_create();
	 angle3=op_prg_list_create();
	 angle4=op_prg_list_create();
     numNeigh1=op_prg_list_create();
	 numNeigh2=op_prg_list_create();
	 numNeigh3=op_prg_list_create();
	 numNeigh4=op_prg_list_create();
     angle=op_prg_list_create();

if((mobile==1)&& (op_sim_time()>=10.0))
	{
	// printf("enter dramatic mode\n");
	 //printf("\n");
	  if(r_dist<r_trans)
		  {
		   printf("exist dramatic mode\n");
		  //  printf("\n");
		  NC =3;
		  }
	}
else
	{
	for(i=0;i<op_prg_list_size(neighbour_maintainance_list);i++)
	{
	 neighbour = (int *)op_prg_mem_alloc(sizeof(int));
	 numNeigh=(int *)op_prg_mem_alloc(sizeof(int));
 	 nei_entry = (NeighbourMaintainanceEntry *) op_prg_list_access(neighbour_maintainance_list,i);
	 *neighbour=nei_entry->node;
	 *numNeigh=nei_entry->neighbourNum;
	 if(*neighbour == 3)
     {
	  NC=3;
	  break;
	  }
	 itoa(*neighbour,temp_neighbour,10);
	 temp_name=(char *)op_prg_mem_alloc(sizeof("top.Campus Network.node_"));
     strcpy(temp_name,"top.Campus Network.node_");
     strcat(temp_name,temp_neighbour);
	 neighId=op_id_from_hierarchical_name(temp_name);
	 op_prg_mem_free(temp_name);

	 op_ima_obj_attr_get(neighId,"x position", &neigh_x_position);
     op_ima_obj_attr_get(neighId,"y position", &neigh_y_position);

	 op_ima_obj_attr_get(neighId,"Residual_energy",&power);
	 dist_neigh_to_sour=sqrt((neigh_x_position-my_x_position_now)*(neigh_x_position-my_x_position_now)+(neigh_y_position-my_y_position_now)*(neigh_y_position-my_y_position_now));
	 dist_neigh_to_sink= (double *)op_prg_mem_alloc(sizeof(double));
	 *dist_neigh_to_sink=sqrt((neigh_x_position-destination_x_position)*(neigh_x_position-destination_x_position)+(neigh_y_position-destination_y_position)*(neigh_y_position-destination_y_position));
	 theta = (double *)op_prg_mem_alloc(sizeof(double));
	 *theta=acos((r_dist*r_dist+dist_neigh_to_sour*dist_neigh_to_sour-(*dist_neigh_to_sink)*(*dist_neigh_to_sink))/(2*dist_neigh_to_sour*r_dist));
	 //printf("theta is %f, distance is %f\n",*theta,*dist_neigh_to_sink);

	 if(dist_neigh_to_sour<=r_trans)
		 {
		 if(*dist_neigh_to_sink<=r_dist)
	      {
		 //  printf("neighour %d is valid\n",*neighbour);
		  if(dist_neigh_to_sour<= sqrt(2)/2*r_trans)
			  {
			   if(neigh_y_position<neigh_x_position*((destination_y_position-my_y_position_now)/(destination_x_position-my_x_position_now))+(my_y_position_now*destination_x_position-destination_y_position*my_x_position_now)/(destination_x_position-my_x_position_now))
				   {
				      //  printf("subregion3\n");
				     	op_prg_list_insert(neighcond_3,neighbour,OPC_LISTPOS_TAIL);
						//printf("sub3 is %d\n",*(int *)op_prg_list_access(neighcond_3,0));
						r3_totalNumNeigh+=*numNeigh;
						r3_power+= power;
						totaldist_3+=*dist_neigh_to_sink;
						op_prg_list_insert(numNeigh3,numNeigh,OPC_LISTPOS_TAIL);
						op_prg_list_insert(dislist3,dist_neigh_to_sink,OPC_LISTPOS_TAIL);
						op_prg_list_insert(angle3,theta,OPC_LISTPOS_TAIL);
				   }
			   else
				   {
				      //  printf("subregion1\n");
				     	op_prg_list_insert(neighcond_1,neighbour,OPC_LISTPOS_TAIL);
					  //  printf("sub1 is %d\n",*(int *)op_prg_list_access(neighcond_1,0));
						r1_totalNumNeigh+=*numNeigh;
						r1_power+= power;
						totaldist_1+=*dist_neigh_to_sink;
						op_prg_list_insert(numNeigh1,numNeigh,OPC_LISTPOS_TAIL);
						op_prg_list_insert(dislist1,dist_neigh_to_sink,OPC_LISTPOS_TAIL);
						op_prg_list_insert(angle1,theta,OPC_LISTPOS_TAIL);
				   }
              }
		  else
			   {
			   if(neigh_y_position<neigh_x_position*((destination_y_position-my_y_position_now)/(destination_x_position-my_x_position_now))+(my_y_position_now*destination_x_position-destination_y_position*my_x_position_now)/(destination_x_position-my_x_position_now))
				   {
				       // printf("subregion4\n");
				     	op_prg_list_insert(neighcond_4,neighbour,OPC_LISTPOS_TAIL);
						//  printf("sub4 is %d\n",*(int *)op_prg_list_access(neighcond_4,0));
						r4_power+= power;
						r4_totalNumNeigh+=*numNeigh;
						totaldist_4+=*dist_neigh_to_sink;
						op_prg_list_insert(numNeigh4,numNeigh,OPC_LISTPOS_TAIL);
						op_prg_list_insert(dislist4,dist_neigh_to_sink,OPC_LISTPOS_TAIL);
						op_prg_list_insert(angle4,theta,OPC_LISTPOS_TAIL);
				   }
			   else
				   {
				      //  printf("subregion2\n");
				     	op_prg_list_insert(neighcond_2,neighbour,OPC_LISTPOS_TAIL);
						//printf("sub2 is %d\n",*(int *)op_prg_list_access(neighcond_2,0));
						r2_power+= power;
						r2_totalNumNeigh+=*numNeigh;
						totaldist_2+=*dist_neigh_to_sink;
						op_prg_list_insert(numNeigh2,numNeigh,OPC_LISTPOS_TAIL);
						op_prg_list_insert(dislist2,dist_neigh_to_sink,OPC_LISTPOS_TAIL);
						op_prg_list_insert(angle2,theta,OPC_LISTPOS_TAIL);
				   }
              }

		    }
		 else
			 op_prg_list_insert(angle,theta,OPC_LISTPOS_TAIL);
		 }
	 // else
		//  printf("neighbor %d is invalid\n",*neighbour);
	   }

if((op_prg_list_size(angle)==op_prg_list_size(neighbour_maintainance_list))&&(userighthand<3)&&(op_prg_list_size(angle)>0)&&(op_sim_time()>10.0))
	{//reference
       // n=Bubble_Sort(angle);
	     //low_index=Select_index_target(angle,n);
  
	     NC=*(int *)op_prg_mem_alloc(sizeof(int));
	     NC=*(int *)op_prg_list_access(neighbour_maintainance_list,0);
	     userighthand+=1;
	     printf("enter into right hand, userrighthead is %d,NC is %d\n",userighthand,NC);
	   }
else
	{
if(op_prg_list_size(neighcond_1)!=0)
r1_averpower=r1_power/op_prg_list_size(neighcond_1);
if(op_prg_list_size(neighcond_2)!=0)
r2_averpower=r2_power/op_prg_list_size(neighcond_2);
if(op_prg_list_size(neighcond_3)!=0)
r3_averpower=r3_power/op_prg_list_size(neighcond_3);
if(op_prg_list_size(neighcond_4)!=0)
r4_averpower=r4_power/op_prg_list_size(neighcond_4);
//printf("%f %f %f %f, %d %d %d %d\n",r1_power,r2_power,r3_power,r4_power,op_prg_list_size(neighcond_1),op_prg_list_size(neighcond_2),op_prg_list_size(neighcond_3),op_prg_list_size(neighcond_4));
//printf("%f, %f, %f, %f\n",r1_averpower,r2_averpower,r3_averpower,r4_averpower);
powerlist = op_prg_list_create();
op_prg_list_insert(powerlist,&r1_averpower,OPC_LISTPOS_TAIL);
op_prg_list_insert(powerlist,&r2_averpower,OPC_LISTPOS_TAIL);  
op_prg_list_insert(powerlist,&r3_averpower,OPC_LISTPOS_TAIL);  
op_prg_list_insert(powerlist,&r4_averpower,OPC_LISTPOS_TAIL); 
n=Bubble_Sort(powerlist);

 if((n>0) && (NC!=3))
 {
  if(n==r4_averpower)
	  {
      NC=Select_neighbour_node(neighcond_4,r4_power,dislist4,totaldist_4,angle4,numNeigh4,r4_totalNumNeigh);
      }
  else if(n==r2_averpower)
	  {
      NC=Select_neighbour_node(neighcond_2,r2_power,dislist2,totaldist_2,angle2,numNeigh2,r2_totalNumNeigh);
      }
  else if(n==r3_averpower)
      {
      NC=Select_neighbour_node(neighcond_3,r3_power,dislist3,totaldist_3,angle3,numNeigh3,r3_totalNumNeigh);
      }
  else if(n==r1_averpower)
      {
      NC=Select_neighbour_node(neighcond_1,r1_power,dislist1,totaldist_1,angle1,numNeigh1,r1_totalNumNeigh);
      }
  
 }
}
}
 


//	NC= 0;
op_prg_list_free(neighcond_1);
op_prg_list_free(neighcond_2);
op_prg_list_free(neighcond_3);
op_prg_list_free(neighcond_4);
op_prg_list_free(dislist1);
op_prg_list_free(dislist2);
op_prg_list_free(dislist3);
op_prg_list_free(dislist4);
op_prg_list_free(angle1);
op_prg_list_free(angle2);
op_prg_list_free(angle3);
op_prg_list_free(angle4);
op_prg_list_free(powerlist);
op_prg_list_free(numNeigh1);
op_prg_list_free(numNeigh2);
op_prg_list_free(numNeigh3);
op_prg_list_free(numNeigh4);
op_prg_list_free(angle);

result_list=op_prg_list_create();
int_ptr = op_prg_mem_alloc(sizeof(int));
*int_ptr = NC;
op_prg_list_insert(result_list,int_ptr,OPC_LISTPOS_TAIL);
FRET (result_list);	
}
/*print list of int*/
void print_int_list_copy__YAO_CTRL_UNIT(List* list)
{
	int		i;
	int		content;
	
	FIN(print_list_copy__YAO_CTRL_UNIT(List* list));
	
	for (i=0; i<op_prg_list_size(list); ++i)
	{
		content = *(int*)op_prg_list_access(list, i);
		printf("%d,",content);
	}
	printf("end\n");
	
	FOUT;
}

/*print list as ptr*/
void print_ptr_list(List* list)
{
	int		i;
	int*		content;
	
	FIN(void print_ptr_list(List* list));
	
	printf("(HEAD=%d) ",list);
	
	for (i=0; i<op_prg_list_size(list); ++i)
	{
		content = (int*)op_prg_list_access(list, i);
		printf("%d,",content);
	}
	printf("end\n");
	
	FOUT;
}


//remove the elements in list1 from list2
void removeListFromList(List* list1, List* list2)
{
	int		i;
	int int_temp;
	int* int_ptr_temp;
	
	FIN(void removeListFromList(List* list1, List* list2));
	
	for (i=0; i<op_prg_list_size(list2); i++)
	{
		int_temp = *(int*)op_prg_list_access(list2, i);
			
		if (exist_intnum(int_temp, list1))		
		{
			int_ptr_temp = (int*) op_prg_list_remove(list2, i);
			op_prg_mem_free(int_ptr_temp);
			i--;
		}
	}
	
	FOUT;
}

void printStrategyList(void)
{
	int i,j;
	Condition2PortMapEntry* C2PM_entry = OPC_NIL;
	TargetCondition* targetCondition = OPC_NIL;

	FIN(void printStrategyList(void));
	
	printf("********start print strategyList\n");
	
	for(i=0;i<op_prg_list_size(C2PME_list);i++)
	{
		C2PM_entry = (Condition2PortMapEntry*) op_prg_list_access(C2PME_list, i);
		printf("C2PM_entry#%d\n",i);
		printf("portLabel(%d)\n",C2PM_entry->portLabel);
		
		for (j=0;j<op_prg_list_size(C2PM_entry->targetCondition_list);j++)
		{
		
			targetCondition = (TargetCondition*) op_prg_list_access(C2PM_entry->targetCondition_list, j);
			
			printf("targetCondition#%d\n",j);
			printf("fieldLabel(%d);",targetCondition->fieldLabel);
			printf("subfieldLabel_list:");
			print_int_list_copy__YAO_CTRL_UNIT(targetCondition->subfieldLabel_list);	
		}
	}
	printf("********end print strategyList\n");
	
	FOUT;
}

/**********basic*****************/

void updateStrategy (Condition2PortMapEntry* C2PM_entry)
{
	int i;
	Condition2PortMapEntry* C2PM_entry_temp = OPC_NIL;
	TargetCondition* targetCondition_temp = OPC_NIL;
	Boolean isEntryExisted = OPC_FALSE;
	
	FIN(void updateStrategy (Condition2PortMapEntry* C2PM_entry));
	
	for (i=0; i<op_prg_list_size(C2PME_list); i++)
	{
		C2PM_entry_temp = (Condition2PortMapEntry*) op_prg_list_access(C2PME_list, i);
		
		op_sim_end("C2PME_list is not empty @ updateStrategy()","","","");
		
		//to be finished
		/*
		for (j=0; j<op_prg_list_size(C2PM_entry_temp->targetCondition_list); j++)
		{
			targetCondition_temp = (TargetCondition*) op_prg_list_access(C2PM_entry_temp->targetCondition_list, j);
					
			for (k=0; k<op_prg_list_size(targetCondition_temp->subfieldLabel_list); k++)
			{
				switch (targetCondition_temp->fieldLabel)
				{
					case TOLERANCE_FIELD:
					{
						int int_temp;
						int_temp = *(int*) op_prg_list_access(targetCondition_temp->subfieldLabel_list, k);
						
						break;
					}
					default:
					{
						op_sim_end("UNKNOWN field @ updateStrategy()","","","");
					}
				
				}
				
			}
			
		}
		*/	
	}
	
	if (isEntryExisted == OPC_FALSE)
	{
		//record the condition2PortMapEntry
		C2PM_entry_temp = op_prg_mem_alloc(sizeof(Condition2PortMapEntry));
		C2PM_entry_temp->portLabel = C2PM_entry->portLabel;
		C2PM_entry_temp->targetCondition_list = op_prg_list_create();	
		op_prg_list_insert(C2PME_list, C2PM_entry_temp, OPC_LISTPOS_TAIL);
		
		for (i=0; i<op_prg_list_size(C2PM_entry->targetCondition_list); i++)
		{
			TargetCondition* targetCondition_temp2 = OPC_NIL;
			
			//record the target condition
			targetCondition_temp2 = (TargetCondition*) op_prg_list_access(C2PM_entry->targetCondition_list, i);			
			targetCondition_temp = op_prg_mem_alloc(sizeof(TargetCondition));
			targetCondition_temp->fieldLabel = targetCondition_temp2->fieldLabel;
			targetCondition_temp->subfieldLabel_list = op_prg_list_create();
			op_prg_list_elems_copy (targetCondition_temp2->subfieldLabel_list, targetCondition_temp->subfieldLabel_list);
			op_prg_list_insert(C2PM_entry_temp->targetCondition_list, targetCondition_temp, OPC_LISTPOS_TAIL);
		}
	}
	
	FOUT;
}

		
void peerUpdate (int nodeAddr)
{
	int i;
	Pkt4SR* pkt4SR;
	
	FIN(void peerUpdate (int nodeAddr));
		
	//check the buffered list of pkt4SR
	for (i=0; i<op_prg_list_size(pkt4SR_list); i++)
	{

		pkt4SR = (Pkt4SR*) op_prg_list_access(pkt4SR_list, i);
		
		if ( exist_intnum(nodeAddr, pkt4SR->secondaryReceivers_list) )
		{
			Packet* pkt_ptr;
			List* secondaryReceivers_list;	
			Ici* ici_ptr_temp;
			
			remove_intnum(nodeAddr, pkt4SR->secondaryReceivers_list);
			
			if (op_prg_list_size(pkt4SR->secondaryReceivers_list)<1)
			{
				pkt_ptr = pkt4SR->pkt_ptr;
				op_prg_list_free(pkt4SR->secondaryReceivers_list);
				op_prg_mem_free(pkt4SR);	
				secondaryReceivers_list = op_prg_list_create();
			}
			else
			{
				pkt_ptr = op_pk_copy(pkt4SR->pkt_ptr);
				secondaryReceivers_list = pkt4SR->secondaryReceivers_list;
			}
					
			op_pk_nfd_set ( pkt_ptr,"Dst", nodeAddr);
			op_pk_nfd_set ( pkt_ptr,"before_last_hop", my_node_addr);
			op_pk_nfd_set ( pkt_ptr,"last_hop", my_node_addr);
			op_pk_nfd_set ( pkt_ptr,"next_hop", nodeAddr);
			op_pk_nfd_set ( pkt_ptr,"TTL", 6);
			//op_pk_nfd_set ( pkt_ptr,"Sequence_num", seq_num_temp);	
			//op_pk_nfd_set_ptr (pkt_ptr, "C2PM_entry", condition2PortMapEntry, op_prg_mem_copy_create, op_prg_mem_free, sizeof (Condition2PortMapEntry));
			op_pk_nfd_set_ptr (pkt_ptr, "secondary_receivers_list", secondaryReceivers_list, op_prg_mem_copy_create, op_prg_mem_free, sizeof (List));
			
			ici_ptr_temp = op_ici_create("dsdv_ip_to_mac_ici");
			op_ici_attr_set(ici_ptr_temp,"type",1);
			op_ici_attr_set(ici_ptr_temp,"subtype",HELLO_PK_TYPE);
			op_ici_attr_set (ici_ptr_temp, "NextHop", -2);
			op_pk_ici_set(pkt_ptr, ici_ptr_temp);

			op_pk_send (pkt_ptr, OUTPUT_STRM);			
			
			//op_sim_end("@ peerUpdate()", "", "", "");
			printf("peerUpdate from node%d to node%d\n",my_node_addr,nodeAddr);
			
		}					
		
	}
	

	FOUT;
}


List* checkNeighourReceivers(List* receivers_list)
{
	int i;
	int nodeAddr_temp;
	
	List* result_list = OPC_NIL;
	
	FIN(List* checkNeighourReceivers(List* receivers_list));
	
	result_list = op_prg_list_create();
		
	//get a list of receivers who are neighbour
	for (i=0; i<op_prg_list_size(receivers_list); i++)
	{

		nodeAddr_temp = *(int*) op_prg_list_access( receivers_list, i);
		
		if ( exist_intnum(nodeAddr_temp, neighbour_list) )
		{
			int* nodeAddr_ptr;
			nodeAddr_ptr = op_prg_mem_alloc(sizeof (int));
			*nodeAddr_ptr = nodeAddr_temp ;
			op_prg_list_insert(result_list, nodeAddr_ptr, OPC_LISTPOS_TAIL);	
		}					
		
	}
	
	if (op_prg_list_size(result_list)<1)
	{
		op_prg_list_free(result_list);
		result_list = OPC_NIL;
	}
	
	FRET(result_list);
}

List* getTargetNodesList(int targetsNum, int fixedNodesNum)
{
	int i;
	int* nodeAddr_ptr;
	List* targetNodes_list = OPC_NIL;
	
	FIN(List* getTargetNodesList(int targetsNum, int fixedNodesNum));
	
	targetNodes_list = op_prg_list_create();
		
	//get target nodes list
	for (i=0; i<targetsNum; i++)
	{
		nodeAddr_ptr = op_prg_mem_alloc(sizeof (int));
		
		//add a new target node node
		*nodeAddr_ptr = my_node_addr;
		while ( (*nodeAddr_ptr == my_node_addr) || (exist_intnum(*nodeAddr_ptr, targetNodes_list)) )
		{
		
			if (i<fixedNodesNum)
			{
				*nodeAddr_ptr = rand()%FN_NUM + 1 ;
			}
			else
			{
				*nodeAddr_ptr = rand()%MN_NUM + 1 + FN_NUM ;
			}
		}
						
		op_prg_list_insert(targetNodes_list, nodeAddr_ptr, OPC_LISTPOS_TAIL);	
	}
	
	FRET(targetNodes_list);
}

int getPrimaryReceiver(List* targetNodes_list)
{
	int* nodeAddr_ptr;
	int targetsNum;
	int selectedIndex;
	int resultNode;
	
	FIN(int getPrimaryReceiver(List* targetNodes_list));
	
	targetsNum = op_prg_list_size(targetNodes_list);
	selectedIndex = rand()%targetsNum;
	while (*(int*) op_prg_list_access(targetNodes_list, selectedIndex) > 50)
	{
		selectedIndex = rand()%targetsNum;
	}
	nodeAddr_ptr = (int*) op_prg_list_remove(targetNodes_list, selectedIndex);
	resultNode = *nodeAddr_ptr;
	op_prg_mem_free(nodeAddr_ptr);
		
	FRET(resultNode);
}


int getNexthop(int dest_addr)
{
	int i;
	int next_hop = NOT_AVAILABLE;
	int subnetwork_id;
	int dest_node_id;
	int neighbour_node_id;
	
	double my_x_position;
	double my_y_position;
	double dst_x_position;
	double dst_y_position;
	double neighbour_x_position;
	double neighbour_y_position;
	
	double distance_a;
	double distance_b;
	double distance_c;
	double cosine = -1.1;
	
	char str[8];
	
	FIN(int getNexthop(int dest_addr));
	
	subnetwork_id = op_topo_parent (my_node_id);
	op_ima_obj_attr_get(my_node_id, "x position", &my_x_position);
    op_ima_obj_attr_get(my_node_id, "y position", &my_y_position);
	
	sprintf(str, "node_%d" , dest_addr);
	dest_node_id = op_id_from_name (subnetwork_id, OPC_OBJTYPE_NODE_MOB, str);
	op_ima_obj_attr_get(dest_node_id, "x position", &dst_x_position);
    op_ima_obj_attr_get(dest_node_id, "y position", &dst_y_position);		
	
	//printf("my(%f, %f); dst(%f, %f)\n", my_x_position, my_y_position, dst_x_position, dst_y_position);
	distance_a = pow( (my_x_position - dst_x_position),2)+pow( (my_y_position - dst_y_position),2);
	
	for(i=0;i<op_prg_list_size(neighbour_list);i++)
	{
		double cosine_temp;
		int nodeAddr;
		
		nodeAddr = *(int*) op_prg_list_access(neighbour_list, i);
		sprintf(str, "node_%d" , nodeAddr);
		neighbour_node_id = op_id_from_name (subnetwork_id, OPC_OBJTYPE_NODE_MOB, str);
		op_ima_obj_attr_get(neighbour_node_id, "x position", &neighbour_x_position);
		op_ima_obj_attr_get(neighbour_node_id, "y position", &neighbour_y_position);
		
		distance_b = pow( (neighbour_x_position - my_x_position),2)+pow( (neighbour_y_position - my_y_position),2);
		distance_c = pow( (neighbour_x_position - dst_x_position),2)+pow( (neighbour_y_position - dst_y_position),2);
		cosine_temp = (distance_a + distance_b - distance_c) / (2*sqrt(distance_a*distance_b));
		
		if (cosine_temp > cosine)
		{
			cosine = cosine_temp;
			next_hop = nodeAddr;
		}		
	}	
	
	if (next_hop == NOT_AVAILABLE)
	{
		op_sim_end("Can't find next_hop @ getNexthop()", "", "", "");	
	}
	
	FRET(next_hop);

}

//maintain neighbour status
void updateNeighbour (int srcNode, int neighbourNum, double sinkHelloRatio)
{
	NeighbourMaintainanceEntry* NM_entry = OPC_NIL;
	int i,j;
	Boolean isSrcNodeExist = OPC_FALSE;
	
	FIN(void updateNeighbour (int srcNode, int neighbourNum));
	
	for(i=0;i<op_prg_list_size(neighbour_maintainance_list);i++)
	{

		NM_entry = (NeighbourMaintainanceEntry*) op_prg_list_access(neighbour_maintainance_list, i);
		
		if (NM_entry->node == srcNode)
		{
			NM_entry->time = op_sim_time();
			NM_entry->neighbourNum = neighbourNum;
			NM_entry->sinkHelloRatio = sinkHelloRatio;
			isSrcNodeExist = OPC_TRUE;
			//printf("Node%d updates NM_entry: node%d/time(%f)/neighbourNum(%d)/sinkHelloRatio(%f)\n", my_node_addr, NM_entry->node, NM_entry->time, NM_entry->neighbourNum, NM_entry->sinkHelloRatio);

		}
		else 
		{
			double gapTime;
			gapTime = op_sim_time() - NM_entry->time;
			
			if (gapTime > LINK_BREAK_THRESHOLD_TIME)
			{
				int* nodeAddr_ptr;
			
				for(j=0;j<op_prg_list_size(neighbour_list);j++)
				{
					nodeAddr_ptr = (int*) op_prg_list_access(neighbour_list, j);	
					
					if (*nodeAddr_ptr == NM_entry->node)
					{
						nodeAddr_ptr = (int*) op_prg_list_remove(neighbour_list, j);
						op_prg_mem_free(nodeAddr_ptr);
						break;
					}
				}
				
				//op_prg_odb_print_minor("", OPC_NIL);
				printf("Node %d will remove node %d from the neighbour_list\n", my_node_addr, NM_entry->node);
												
				NM_entry = (NeighbourMaintainanceEntry*) op_prg_list_remove(neighbour_maintainance_list, i);
				i--;
				op_prg_mem_free(NM_entry);
				
				//op_sim_end("force end", "", "", "");
			}
		
		}
		
	}
	
	if (!isSrcNodeExist)
	{
		NM_entry = op_prg_mem_alloc(sizeof(NeighbourMaintainanceEntry));
		NM_entry->node = srcNode;
		NM_entry->time = op_sim_time();
		NM_entry->neighbourNum = neighbourNum;
		NM_entry->sinkHelloRatio = sinkHelloRatio;
		//successrate=sinkHelloRatio;
		printf("Node%d adds NM_entry: node%d/time(%f)/neighbourNum(%d)/sinkHelloRatio(%f)\n", my_node_addr, NM_entry->node, NM_entry->time, NM_entry->neighbourNum, NM_entry->sinkHelloRatio);
		op_prg_list_insert(neighbour_maintainance_list, NM_entry, OPC_LISTPOS_TAIL);
	}
		
	FOUT;
}

//categorize a list of neighbour nodes into categories
//return true if nexthopCategory_list has any change; otherwise return false
Boolean categorizeNeighbour (void)
{
	NexthopCategory* nexthopCategory = OPC_NIL;
	int i,j,k;
	Boolean isCategoryModified = OPC_FALSE;
	
	FIN(void categorizeNeighbour (void));
	
	for(i=0;i<op_prg_list_size(nexthopCategory_list);i++)
	{
		List* resultNode_list = OPC_NIL;
		int nodeAddr;
		
		nexthopCategory = (NexthopCategory*) op_prg_list_access(nexthopCategory_list, i);
		
		//printf("categoryLabel is %d\n", nexthopCategory->categoryLabel);
		
		switch (nexthopCategory->categoryLabel)
		{
			case ANY_NC:
			{
				resultNode_list = op_prg_list_create();
				op_prg_list_elems_copy (neighbour_list, resultNode_list);		
				break;
			}
			case SHORTPATH_NC:
			{
				int* nodeAddr_ptr = op_prg_mem_alloc(sizeof (int));
				*nodeAddr_ptr = SINK_ADDR;					
				resultNode_list = op_prg_list_create();
				op_prg_list_insert(resultNode_list, nodeAddr_ptr, OPC_LISTPOS_TAIL);
				break;
			}
			case GUO_NC:
			{
				//add algorithm function here
				resultNode_list = routestrate();
			
				/*		
				if (my_node_addr != SINK_ADDR)
				{
				if (exist_intnum(SINK_ADDR, neighbour_list))
				{
					int* nodeAddr_ptr = op_prg_mem_alloc(sizeof (int));
					*nodeAddr_ptr = SINK_ADDR;					
					resultNode_list = op_prg_list_create();
					op_prg_list_insert(resultNode_list, nodeAddr_ptr, OPC_LISTPOS_TAIL);			
				}
				else if (exist_intnum(4, neighbour_list))
				{
					int* nodeAddr_ptr = op_prg_mem_alloc(sizeof (int));
					*nodeAddr_ptr = 4;					
					resultNode_list = op_prg_list_create();
					op_prg_list_insert(resultNode_list, nodeAddr_ptr, OPC_LISTPOS_TAIL);		
				}	
				}*/
			
				break;
			}			
			default:
			{
				printf("Unknown category_label\n");	
				op_sim_end("Force simulation end", "", "", "");					
				break;
			}
		}
		
		if (resultNode_list == OPC_NIL)
		{
			resultNode_list = op_prg_list_create();
		}
		
		for(j=0;j<op_prg_list_size(nexthopCategory->node_list);j++)
		{
			int* nodeAddr_ptr = OPC_NIL;
			
			nodeAddr_ptr = (int*) op_prg_list_access(nexthopCategory->node_list, j);
						
			if (exist_intnum(*nodeAddr_ptr, neighbour_list) == OPC_FALSE)
			{
				//printf("Node%d: removed node%d which is no longer in neighbour_list @ categorizeNeighbour()\n", my_node_addr,*nodeAddr_ptr);
				nodeAddr_ptr = op_prg_list_remove(nexthopCategory->node_list, j);
				op_prg_mem_free(nodeAddr_ptr);

				isCategoryModified = OPC_TRUE;
			}
		}
		
		
		//update nexthopCategory->node_list according resultNode_list
		for(j=0;j<op_prg_list_size(neighbour_list);j++)
		{
			nodeAddr = *(int*) op_prg_list_access(neighbour_list, j);
			
			if (exist_intnum(nodeAddr, resultNode_list) == OPC_TRUE)
			{				
				if (exist_intnum(nodeAddr, nexthopCategory->node_list) == OPC_FALSE)
				{
					//the nodes who are new added for this category
				
					int* nodeAddr_ptr = op_prg_mem_alloc(sizeof (int));
					*nodeAddr_ptr = nodeAddr;					
					op_prg_list_insert(nexthopCategory->node_list, nodeAddr_ptr, OPC_LISTPOS_TAIL);
					//printf("node %d is added into category %d\n",nodeAddr, nexthopCategory->categoryLabel );	
					
					isCategoryModified = OPC_TRUE;
				}
				else
				{
					//node already in this category
				}
			}
			else
			{
				if (exist_intnum(nodeAddr, nexthopCategory->node_list) == OPC_TRUE)
				{
					//node is not yet match this category so should be removed
				
					int* nodeAddr_ptr = OPC_NIL;
									
					for(k=0;k<op_prg_list_size(nexthopCategory->node_list);k++)
					{
						nodeAddr_ptr = (int*) op_prg_list_access(nexthopCategory->node_list, k);
						
						if (*nodeAddr_ptr == nodeAddr)
						{
							//printf("Node%d: removed node%d which no longer matches current category @ categorizeNeighbour()",my_node_addr, nodeAddr);

						    nodeAddr_ptr = op_prg_list_remove(nexthopCategory->node_list, k);
							op_prg_mem_free(nodeAddr_ptr);
							isCategoryModified = OPC_TRUE;
							break;
						}
					}	
				}		
			}
		}
		
		op_prg_list_free(resultNode_list);
		
	}
		
	FRET(isCategoryModified);
}

/* old version no use but keep in case
//categorize a neighbour node into category
void categorizeNeighbour (int nodeAddr)
{
	NexthopCategory* nexthopCategory = OPC_NIL;
	Boolean is_this_category = OPC_FALSE;
	int i;
	int j;
	
	FIN(void categorizeNeighbour (int nodeAddr));
	
	for(i=0;i<op_prg_list_size(nexthopCategory_list);i++)
	{
		nexthopCategory = (NexthopCategory*) op_prg_list_access(nexthopCategory_list, i);
		
		switch (nexthopCategory->categoryLabel)
		{
			case ANY_NC:
			{
				is_this_category = OPC_TRUE;			
				break;
			}
			case SHORTPATH_NC:
			{
				if (nodeAddr == SINK_ADDR)
				{
					is_this_category = OPC_TRUE;
				}
				break;
			}
			case GUO_NC:
			{
				//add categorizing condition here
				//if (nodeAddr == SINK_ADDR)
				//{
				//	is_this_category = OPC_TRUE;
				//}
				break;
			}			
			default:
			{
				printf("Unknown category_label\n");	
				op_sim_end("Force simulation end", "", "", "");					
				break;
			}
		}
		
		if (is_this_category == OPC_TRUE)
		{
			if (exist_intnum(nodeAddr, nexthopCategory->node_list) == OPC_FALSE)
			{
				int* nodeAddr_ptr = op_prg_mem_alloc(sizeof (int));
				*nodeAddr_ptr = nodeAddr;					
				op_prg_list_insert(nexthopCategory->node_list, nodeAddr_ptr, OPC_LISTPOS_TAIL);
				//printf("node %d is added into category %d\n",nodeAddr, nexthopCategory->categoryLabel );	
			}
			else
			{
				//node already in this category
			}
		}
		else
		{
			if (exist_intnum(nodeAddr, nexthopCategory->node_list) == OPC_TRUE)
			{
				//node is not yet match this category so should be removed
			
				int* nodeAddr_ptr = OPC_NIL;
								
				for(j=0;j<op_prg_list_size(nexthopCategory->node_list);j++)
				{
					nodeAddr_ptr = (int*) op_prg_list_access(nexthopCategory->node_list, j);
					
					if (*nodeAddr_ptr == nodeAddr)
					{
						nodeAddr_ptr = op_prg_list_remove(nexthopCategory->node_list, j);
						op_prg_mem_free(nodeAddr_ptr);
						op_sim_end("Removed node no longer match current category", "", "", "");
						break;
					}
				}	
			}		
		}

		is_this_category = OPC_FALSE;
	}
		
	FOUT;
}
*/



Boolean getRealCondition (ConditionField* conditionField, QualityOfService* QoS)
{
	Boolean realCoditionGotten = OPC_FALSE;
	int i;
	
	FIN(Boolean getRealCondition (ConditionField* conditionField, QualityOfService* QoS));
	
	switch (conditionField->fieldLabel)
	{
		case TOLERANCE_FIELD: 
		{

			int subLabel;
			
			for(i=0;i<op_prg_list_size(conditionField->definedCondition_list);i++)
			{
			
				subLabel = *(int*) op_prg_list_access(conditionField->definedCondition_list, i);

				switch (subLabel)
				{
					case DELAY_SUBFIELD:
					{
						int* int_ptr = op_prg_mem_alloc(sizeof(int)); 
						*int_ptr = UNMATCHED_FLAG;
						if (QoS->delayTolerant == OPC_TRUE)
						{
							*int_ptr = MATCHED_FLAG;
						}
						//op_prg_odb_print_minor("", OPC_NIL);
						//printf("Flag of DELAY_SUBFIELD is %d\n", *int_ptr);
						op_prg_list_insert(conditionField->realCondition_list, int_ptr, OPC_LISTPOS_TAIL);
						break;
					}
					default:
					{
						op_sim_end("Unrecognized subLabel", "", "", "");
						break;
					}
				}
			}
			break;
		}
		
		default:
		{
			op_sim_end("Unrecognized field label", "", "", "");
			break;
		}
	}
	
	realCoditionGotten = OPC_TRUE;

	FRET(realCoditionGotten);
}


//return True if condition is converted successfully.
Boolean convertCondition (QualityOfService* QoS)
{
	ConditionField* conditionField_ptr = OPC_NIL;
	Boolean RealConditionGotten = OPC_FALSE;
	int i;
	
	FIN(Boolean convertCondition (QualityOfService* QoS));
	
	for(i=0;i<op_prg_list_size(conditionField_list);i++)
	{
		conditionField_ptr = (ConditionField*) op_prg_list_access(conditionField_list, i);
		
		//clear the real condition list if not clean
		op_prg_list_free(conditionField_ptr->realCondition_list);		
		
		RealConditionGotten = getRealCondition(conditionField_ptr, QoS);
		
		if (RealConditionGotten == OPC_FALSE)
		{
			op_sim_end("Fail to getRealCondition()", "", "", "");
			break;
		}
		
	}
	
	RealConditionGotten = OPC_TRUE;	
	FRET(RealConditionGotten);
}

Boolean checkTargetCondition(ConditionField* conditionField, TargetCondition* targetCondition)
{
	int targetSubfield;
	int subfield;
	int flag;
	int i,j;
	
	FIN( Boolean checkTargetCondition(ConditionField* conditionField, TargetCondition* targetCondition) );
	
	for(i=0;i<op_prg_list_size(targetCondition->subfieldLabel_list);i++)
	{
		targetSubfield = *(int*) op_prg_list_access(targetCondition->subfieldLabel_list, i);
		
		for(j=0;j<op_prg_list_size(conditionField->definedCondition_list);j++)
		{	
			subfield = *(int*) op_prg_list_access(conditionField->definedCondition_list, j);
			
			if (targetSubfield == subfield)
			{
				flag = *(Boolean*) op_prg_list_access(conditionField->realCondition_list, j);
				
				//op_prg_odb_print_minor("", OPC_NIL);
				//printf("Checking: Flag of Field%d-SubField%d is %d\n", conditionField->fieldLabel, subfield, flag);
				
				if ( flag == MATCHED_FLAG )
				{
					continue;
				}
				else
				{
					FRET(OPC_FALSE);
				}				
			}			
		}
	}	
	
	FRET(OPC_TRUE);	
}

int mapStrategy ( List* conditionField_list_LOCAL )//conditionField_list is a global var
{
	Condition2PortMapEntry* C2PME = OPC_NIL;
	TargetCondition* targetCondition = OPC_NIL;
	ConditionField* conditionField = OPC_NIL;
	Boolean isSatisfied;
	int portLabel = DEFAULT_PORT;
	int i,j,k;
	
	FIN( int mapStrategy ( List* conditionField_list_LOCAL ) );
	
	//op_prg_odb_print_minor("", OPC_NIL);
	//printf("%d\n", op_prg_list_size(C2PME_list));
	//print_ptr_list(C2PME_list);
	
	for(i=0;i<op_prg_list_size(C2PME_list);i++)
	{
		C2PME = (Condition2PortMapEntry*) op_prg_list_access(C2PME_list, i);
		
		//printf("%d\n", op_prg_list_size(C2PME->targetCondition_list));
		//print_ptr_list(C2PME->targetCondition_list);
		
		for(j=0;j<op_prg_list_size(C2PME->targetCondition_list);j++)
		{
			targetCondition = (TargetCondition*) op_prg_list_access(C2PME->targetCondition_list, j);
			
			//printf("%d\n", op_prg_list_size(conditionField_list_LOCAL));
			
			for(k=0;k<op_prg_list_size(conditionField_list_LOCAL);k++)
			{
				conditionField = (ConditionField*) op_prg_list_access(conditionField_list_LOCAL, k);
				
				//printf("conditionField->fieldLabel=%d, targetCondition->fieldLabel=%d\n", conditionField->fieldLabel, targetCondition->fieldLabel);
				
				if ( conditionField->fieldLabel == targetCondition->fieldLabel )
				{
					
					isSatisfied = checkTargetCondition(conditionField, targetCondition);
					
					if (isSatisfied == OPC_TRUE)
					{
						portLabel = C2PME->portLabel;
					}
					
					FRET(portLabel);
				}
			}			
		}
	}

	FRET(portLabel);
}

ForwardingPara* getForwardingParaByPort(Port* port)
{
	NexthopCategory* nexthopCategory = OPC_NIL;
	ForwardingPara* forwardingPara = OPC_NIL;
	int nexthop = NOT_AVAILABLE;
	int categoryLabel;
	int i,j;
	
	FIN( ForwardingPara* getForwardingParaByPort(Port* port) );
	
	forwardingPara = op_prg_mem_alloc(sizeof(ForwardingPara));
	forwardingPara->nexthopCandidate_list = op_prg_list_create();
	
	if (port->categoryLabel_list != OPC_NIL)
	{
		for(i=0;i<op_prg_list_size(port->categoryLabel_list);i++)
		{
			categoryLabel = *(int*) op_prg_list_access(port->categoryLabel_list, i);

			for(j=0;j<op_prg_list_size(nexthopCategory_list);j++)
			{
				nexthopCategory = (NexthopCategory*) op_prg_list_access(nexthopCategory_list, j);
				
				if (nexthopCategory->categoryLabel == categoryLabel )
				{
					//printf("Category is matched as Label %d\n", categoryLabel);		
				
					if ( op_prg_list_size(nexthopCategory->node_list) != 0 )
					{	
						int candidateNumBound;
						
						//limit the number of candadates
						if ( port->candidateMaxNum < op_prg_list_size(nexthopCategory->node_list) )
							candidateNumBound = port->candidateMaxNum;
						else
							candidateNumBound = op_prg_list_size(nexthopCategory->node_list);											
						
						while (op_prg_list_size(forwardingPara->nexthopCandidate_list) < candidateNumBound) 
						{
							int* int_ptr_temp = OPC_NIL;
							int* int_ptr_temp2 = OPC_NIL;
							
							//cycle the nexthopCategory->node_list to avoid use same node every time
							int_ptr_temp = (int*) op_prg_list_remove(nexthopCategory->node_list, OPC_LISTPOS_HEAD);
							//nexthop = *(int*) op_prg_list_access(nexthopCategory->node_list, OPC_LISTPOS_HEAD);	
							int_ptr_temp2 = op_prg_mem_alloc(sizeof(int));
							*int_ptr_temp2 = *int_ptr_temp;
							op_prg_list_insert(nexthopCategory->node_list, int_ptr_temp, OPC_LISTPOS_TAIL);						
							op_prg_list_insert(forwardingPara->nexthopCandidate_list, int_ptr_temp2, OPC_LISTPOS_TAIL);							
						}		
						
						FRET(forwardingPara);
					}
					else
					{
						//printf("Can't find nexthop from category %d\n", categoryLabel);
						//op_sim_end("@getForwardingParaByPort()","","","");
					}					
				}
				else
				{
					continue;
				}
				
				break;
			}
		}
	}
	else if (port->forwardingPattern == BROADCAST_FP)
	{		
		int* int_ptr_temp = OPC_NIL;
		
		int_ptr_temp = op_prg_mem_alloc(sizeof(int));
		*int_ptr_temp = BROADCAST_ADDR;
		op_prg_list_insert(forwardingPara->nexthopCandidate_list, int_ptr_temp, OPC_LISTPOS_TAIL);	
		FRET(forwardingPara);	
	}	
	
	//printf("Can't find nexthop from port %d\n", port->portLabel);
	FRET(forwardingPara);
}


ForwardingPara* translatePort(int portLabel)
{

	ForwardingPara* forwardingPara = OPC_NIL;
	Port* port = OPC_NIL;
	int i;
	
	FIN( ForwardingPara* translatePort(int portLabel) );
	
	//Locate port entry, and get correponding category and pattern
	for(i=0;i<op_prg_list_size(port_list);i++)
	{
		port = (Port*) op_prg_list_access(port_list, i);
		
		//printf("port->portLabel is %d, portLabel is %d \n",port->portLabel, portLabel);
		
		if ( port->portLabel == portLabel)
		{
			//op_prg_odb_print_minor("", OPC_NIL);
			//printf("Port is matched as Label %d\n",portLabel);
			break;

		}
		else 
		{
			port = OPC_NIL;
		}
		
	}
	
	if ( port == OPC_NIL )
	{
		printf("Port label is %d\n",portLabel);
		op_sim_end("@Unrecognized port label","","","");
	}
	else
	{
		forwardingPara = getForwardingParaByPort(port);		
	}
	
	FRET(forwardingPara);
}

ForwardingPara* getFwdPara(MatchFields* matchFields, QualityOfService* QoS)
{
	int portLabel;
	ForwardingPara* forwardingPara = OPC_NIL;
	
	FIN(ForwardingPara* getFwdPara(MatchFields* matchFields, QualityOfService* QoS));
	
	// matchFields no use for now
	
	if (conditionField_list == OPC_NIL)
	{
		portLabel = DEFAULT_PORT;
		op_prg_odb_print_minor("conditionField_list is empty, using default port", OPC_NIL);
		op_sim_end("Force end @ getFwdPara()","","","");
	}	
	else if (convertCondition(QoS))
	{
		portLabel = GUO_PORT;//mapStrategy(conditionField_list);
	}
	else
	{
		op_sim_end("fail to convert condition","","","");
	}
	
	//printf("node%d:portLabel(%d)\n", my_node_addr, portLabel);
	forwardingPara = translatePort(portLabel);

	FRET(forwardingPara);

}

/*****compound*********************************/

void helloPktProcessing(Packet* pkt_ptr)
{
	int src_node;
	int neighbourNum;
	int sinkHelloNum;
	double sinkHelloRatio;
	//int i;
	Boolean isCategoryChanged;
	
	FIN(void helloPktProcessing(Packet* pkt_ptr));
	
	//op_prg_odb_print_minor("rcv HELLO", OPC_NIL);
		
	op_pk_nfd_get(pkt_ptr, "Src",   &src_node);	
	op_pk_nfd_get(pkt_ptr, "Neighbour_num", &neighbourNum);
	op_pk_nfd_get(pkt_ptr, "SinkHello_num", &sinkHelloNum);
	//op_pk_nfd_get(pkt_ptr, "SinkHello_num", &sinkHelloNum);
	sinkHelloRatio = sinkHelloNum/(op_sim_time()/HELLO_INTERVAL);
	
	//printf("Node%d: node%d has sinkHelloNum=%d, so sinkHelloRatio=%f, at t=%f\n", my_node_addr, src_node, sinkHelloNum, sinkHelloRatio, op_sim_time());

	if (src_node == SINK_ADDR)
	{
		sink_hello_num++;
	}

	updateNeighbour(src_node, neighbourNum, sinkHelloRatio);
	
	/*
	printf("Print node%d neighbour_maintainance_list:\n");
	for (i=0;i<op_prg_list_size(neighbour_maintainance_list);i++)
	{
		NeighbourMaintainanceEntry* NM_entry;
		NM_entry = (NeighbourMaintainanceEntry*)op_prg_list_access(neighbour_maintainance_list,i);	
		printf("node%d/time(%f)/neighbourNum(%d)\n", NM_entry->node, NM_entry->time, NM_entry->neighbourNum);
	}
	*/

	//add the node into neighbour_list if not exist
	if (exist_intnum(src_node, neighbour_list) == OPC_FALSE)
	{
		int* int_ptr_temp = op_prg_mem_alloc(sizeof(int));
		*int_ptr_temp = src_node;
		
		op_prg_list_insert (neighbour_list, int_ptr_temp, OPC_LISTPOS_TAIL);
		
		printf("Node%d adds node%d into its neighbour list\n", my_node_addr, src_node);
		
		peerUpdate(src_node);
	}

	isCategoryChanged = categorizeNeighbour(); // input neighbour_list
	
	if (isCategoryChanged)
	{
		op_intrpt_schedule_self ( op_sim_time(), UPDATE_FLOW_CODE);
	}
		
	op_pk_destroy(pkt_ptr);

	FOUT;
}


void ctrlPktProcessing(Packet* pkt_ptr)
{
	Ici* ici_ptr_temp = OPC_NIL;
	Condition2PortMapEntry* condition2PortMapEntry = OPC_NIL;
	//Condition2PortMapEntry* condition2PortMapEntry_temp = OPC_NIL;
	int seq_num_temp;
	int dst_addr;
	double ete_delay;
	int next_hop;
	int last_hop;
	List* secondaryReceivers_list = OPC_NIL;
	List* secondaryReceivers_list_temp = OPC_NIL;
		
	FIN(void ctrlPktProcessing(Packet* pkt_ptr));
	
	op_pk_nfd_get_ptr (pkt_ptr, "C2PM_entry",  &condition2PortMapEntry);	
	//condition2PortMapEntry = (Condition2PortMapEntry *) op_prg_mem_copy_create (condition2PortMapEntry_temp, sizeof (Condition2PortMapEntry));
	op_pk_nfd_get ( pkt_ptr,"Sequence_num", &seq_num_temp);		
	op_pk_nfd_get ( pkt_ptr,"Dst", &dst_addr);	
	op_pk_nfd_get ( pkt_ptr,"next_hop", &next_hop);
	op_pk_nfd_get ( pkt_ptr,"last_hop", &last_hop);

	op_pk_nfd_get_ptr (pkt_ptr, "secondary_receivers_list",  &secondaryReceivers_list_temp);	

	if (secondaryReceivers_list_temp != OPC_NIL)
	{
		secondaryReceivers_list = op_prg_list_create();
		op_prg_list_elems_copy (secondaryReceivers_list_temp, secondaryReceivers_list);
		op_prg_mem_free(secondaryReceivers_list_temp);
	}
	else
	{
		op_sim_end("Error of secondaryReceivers_list_temp @ pkt_handling_in_ctrl", "", "", "");
	}

	if (condition2PortMapEntry == OPC_NIL)
	{
		op_sim_end("Error of condition2PortMapEntry @ pkt_handling_in_ctrl", "", "", "");
	}


	//printf("node%2d received ctrl msg from last_hop node%2d, seq=%d, t=%f\n", my_node_addr, last_hop, seq_num_temp, op_sim_time());

	/*
	if (secondaryReceivers_list == OPC_NIL)
	{
		printf("secondaryReceivers_list is NIL\n");
	}
	else
	{
		printf("The list as ptr:");
		print_ptr_list(secondaryReceivers_list);
		printf("The secondary receivers list is:");
		print_int_list_copy__YAO_CTRL_UNIT(secondaryReceivers_list);
	}
	*/

	if (seq_num_temp > seq_num)
	{

		if (dst_addr == my_node_addr)
		{		
			seq_num = seq_num_temp;	
			
			//op_prg_list_insert(C2PME_list, condition2PortMapEntry, OPC_LISTPOS_TAIL);
			updateStrategy(condition2PortMapEntry);
			//op_prg_odb_print_minor("Strategy is updated", OPC_NIL);
			printf("Ctrl msg (seq=%d) arrived node%2d t=%f\n", seq_num_temp, my_node_addr, op_sim_time());
			op_intrpt_schedule_self ( op_sim_time(), UPDATE_FLOW_CODE);	
			
			ete_delay = op_sim_time () - op_pk_creation_time_get (pkt_ptr);
			op_stat_write (ctrl_ete_delay_global, ete_delay);
			
			
			//printf("The  secondary receivers list is:");
			//print_int_list_copy__YAO_CTRL_UNIT(secondaryReceivers_list);
			
			if (op_prg_list_size(secondaryReceivers_list)>0)
			{
				List* neighbourReceivers_list = OPC_NIL;
				neighbourReceivers_list = checkNeighourReceivers(secondaryReceivers_list);
				
				//if (op_prg_list_size(neighbourReceivers_list)>0)
				if (neighbourReceivers_list != OPC_NIL)
				{
					//printf("Has secondary receivers in neighbour:");
					//print_int_list_copy__YAO_CTRL_UNIT(neighbourReceivers_list);
				
					if (op_prg_list_size(neighbourReceivers_list) == op_prg_list_size(secondaryReceivers_list))
					{
						// don't need record for now
					}
					else
					{
						//record secondaryReceivers_list					
						Pkt4SR* pkt4SR = op_prg_mem_alloc(sizeof (Pkt4SR));
						pkt4SR->secondaryReceivers_list = OPC_NIL;
						pkt4SR->pkt_ptr = OPC_NIL;
						op_prg_list_insert(pkt4SR_list, pkt4SR, OPC_LISTPOS_TAIL);
										
						removeListFromList(neighbourReceivers_list, secondaryReceivers_list);
										
						pkt4SR->secondaryReceivers_list = secondaryReceivers_list;
						pkt4SR->pkt_ptr = op_pk_copy(pkt_ptr);
						op_pk_nfd_set_ptr (pkt4SR->pkt_ptr, "C2PM_entry", condition2PortMapEntry, op_prg_mem_copy_create, op_prg_mem_free, sizeof (Condition2PortMapEntry));
						printf("Recorded secondaryReceivers_list:");
						print_int_list_copy__YAO_CTRL_UNIT(secondaryReceivers_list);
					}
				
					dst_addr = getPrimaryReceiver(neighbourReceivers_list);
					next_hop = BROADCAST_ADDR;//getNexthop(dst_addr);//
					//printf("node%2d choose nexthop node%2d\n", my_node_addr, next_hop);
				
					//op_pk_nfd_set ( pkt_ptr,"Type", CTRL_PK_TYPE);
					//op_pk_nfd_set ( pkt_ptr,"Src", my_node_addr);
					op_pk_nfd_set ( pkt_ptr,"Dst", dst_addr);
					op_pk_nfd_set ( pkt_ptr,"before_last_hop", my_node_addr);
					op_pk_nfd_set ( pkt_ptr,"last_hop", my_node_addr);
					op_pk_nfd_set ( pkt_ptr,"next_hop", next_hop);
					op_pk_nfd_set ( pkt_ptr,"TTL", 6);
					op_pk_nfd_set ( pkt_ptr,"Sequence_num", seq_num_temp);	
					op_pk_nfd_set_ptr (pkt_ptr, "C2PM_entry", condition2PortMapEntry, op_prg_mem_copy_create, op_prg_mem_free, sizeof (Condition2PortMapEntry));
					op_pk_nfd_set_ptr (pkt_ptr, "secondary_receivers_list", neighbourReceivers_list, op_prg_mem_copy_create, op_prg_mem_free, sizeof (List));
					
					ici_ptr_temp = op_ici_create("dsdv_ip_to_mac_ici");
					op_ici_attr_set(ici_ptr_temp,"type",1);
					op_ici_attr_set(ici_ptr_temp,"subtype",HELLO_PK_TYPE);
					op_ici_attr_set (ici_ptr_temp, "NextHop", -2);
					op_pk_ici_set(pkt_ptr, ici_ptr_temp);

					op_pk_send (pkt_ptr, OUTPUT_STRM);		
					printf("Pkt sent to secondary receivers in neighbour\n");

				}
				else
				{
					//record secondaryReceivers_list
					Pkt4SR* pkt4SR = op_prg_mem_alloc(sizeof (Pkt4SR));
					pkt4SR->secondaryReceivers_list = OPC_NIL;
					pkt4SR->pkt_ptr = OPC_NIL;
					op_prg_list_insert(pkt4SR_list, pkt4SR, OPC_LISTPOS_TAIL);
					
					pkt4SR->secondaryReceivers_list = secondaryReceivers_list;
					pkt4SR->pkt_ptr = pkt_ptr;
					op_pk_nfd_set_ptr (pkt4SR->pkt_ptr, "C2PM_entry", condition2PortMapEntry, op_prg_mem_copy_create, op_prg_mem_free, sizeof (Condition2PortMapEntry));
					
					printf("Recorded secondaryReceivers_list:");
					print_int_list_copy__YAO_CTRL_UNIT(secondaryReceivers_list);
				}
			}
			else
			{
				op_pk_destroy(pkt_ptr);	
				op_prg_mem_free(secondaryReceivers_list);
			}
					
		}
		else if ( (next_hop == my_node_addr) || (next_hop == BROADCAST_ADDR) )
		{	
			seq_num = seq_num_temp;
			
			if ( (exist_intnum(my_node_addr, secondaryReceivers_list)) || (dst_addr == NOT_AVAILABLE) )
			{
				//printf("Pkt reveived by secondary receiver which is the next hop\n");
				
				//op_prg_list_insert(C2PME_list, condition2PortMapEntry, OPC_LISTPOS_TAIL);
				updateStrategy(condition2PortMapEntry);
				//op_prg_odb_print_minor("Strategy is updated", OPC_NIL);
				printf("Ctrl msg (seq=%d) arrived node%2d t=%f\n", seq_num_temp, my_node_addr, op_sim_time());
				op_intrpt_schedule_self ( op_sim_time(), UPDATE_FLOW_CODE);	
				
				ete_delay = op_sim_time () - op_pk_creation_time_get (pkt_ptr);
				op_stat_write (ctrl_ete_delay_global, ete_delay);
			
			}
			
			next_hop = BROADCAST_ADDR;//getNexthop(dst_addr);//
			//printf("node%2d choose nexthop node%2d\n", my_node_addr, next_hop);
		
			//op_pk_nfd_set ( pkt_ptr,"Type", CTRL_PK_TYPE);
			//op_pk_nfd_set ( pkt_ptr,"Src", my_node_addr);
			op_pk_nfd_set ( pkt_ptr,"Dst", dst_addr);
			op_pk_nfd_set ( pkt_ptr,"before_last_hop", my_node_addr);
			op_pk_nfd_set ( pkt_ptr,"last_hop", my_node_addr);
			op_pk_nfd_set ( pkt_ptr,"next_hop", next_hop);
			op_pk_nfd_set ( pkt_ptr,"TTL", 6);
			op_pk_nfd_set ( pkt_ptr,"Sequence_num", seq_num_temp);	
			op_pk_nfd_set_ptr (pkt_ptr, "C2PM_entry", condition2PortMapEntry, op_prg_mem_copy_create, op_prg_mem_free, sizeof (Condition2PortMapEntry));
			op_pk_nfd_set_ptr (pkt_ptr, "secondary_receivers_list", secondaryReceivers_list, op_prg_mem_copy_create, op_prg_mem_free, sizeof (List));
			
			ici_ptr_temp = op_ici_create("dsdv_ip_to_mac_ici");
			op_ici_attr_set(ici_ptr_temp,"type",1);
			op_ici_attr_set(ici_ptr_temp,"subtype",HELLO_PK_TYPE);
			op_ici_attr_set (ici_ptr_temp, "NextHop", -2);
			op_pk_ici_set(pkt_ptr, ici_ptr_temp);

			op_pk_send (pkt_ptr, OUTPUT_STRM);
			
			//may delete neighbour nodes from secondaryReceivers_list as they should be able to receive the pkt
			
			//when to free secondaryReceivers_list?
			
			//op_prg_odb_print_minor("CTRL_PKT is sent out", OPC_NIL);
		}
		else if (exist_intnum(my_node_addr, secondaryReceivers_list))
		{	
			printf("Pkt reveived by secondary receiver which is NOT the next hop\n");
			
			seq_num = seq_num_temp;	
		
			//op_prg_list_insert(C2PME_list, condition2PortMapEntry, OPC_LISTPOS_TAIL);
			updateStrategy(condition2PortMapEntry);
			//op_prg_odb_print_minor("Strategy is updated", OPC_NIL);
			printf("Ctrl msg (seq=%d) arrived node%2d t=%f\n", seq_num_temp, my_node_addr, op_sim_time());
			op_intrpt_schedule_self ( op_sim_time(), UPDATE_FLOW_CODE);	
			
			ete_delay = op_sim_time () - op_pk_creation_time_get (pkt_ptr);
			op_stat_write (ctrl_ete_delay_global, ete_delay);
			op_pk_destroy(pkt_ptr);	
			op_prg_list_free(secondaryReceivers_list);
			op_prg_mem_free(secondaryReceivers_list);
		}
		else
		{
			op_pk_destroy(pkt_ptr);	
			op_prg_list_free(secondaryReceivers_list);
			op_prg_mem_free(secondaryReceivers_list);
		}
	}
	else
	{
		//op_sim_end("Received strategy is out-of-date", "", "", "");
		//discard the stratgy_update because of out-of-date seq_num
		op_pk_destroy(pkt_ptr);	
		op_prg_list_free(secondaryReceivers_list);
		op_prg_mem_free(secondaryReceivers_list);
	}

	
	FOUT;
}

/* End of Function Block */

/* Undefine optional tracing in FIN/FOUT/FRET */
/* The FSM has its own tracing code and the other */
/* functions should not have any tracing.		  */
#undef FIN_TRACING
#define FIN_TRACING

#undef FOUTRET_TRACING
#define FOUTRET_TRACING

#if defined (__cplusplus)
extern "C" {
#endif
	void YAO_CTRL_UNIT (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Obtype _op_YAO_CTRL_UNIT_init (int * init_block_ptr);
	void _op_YAO_CTRL_UNIT_diag (OP_SIM_CONTEXT_ARG_OPT);
	void _op_YAO_CTRL_UNIT_terminate (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Address _op_YAO_CTRL_UNIT_alloc (VosT_Obtype, int);
	void _op_YAO_CTRL_UNIT_svar (void *, const char *, void **);


#if defined (__cplusplus)
} /* end of 'extern "C"' */
#endif




/* Process model interrupt handling procedure */


void
YAO_CTRL_UNIT (OP_SIM_CONTEXT_ARG_OPT)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	FIN_MT (YAO_CTRL_UNIT ());

		{
		/* Temporary Variables */
		char			msg0[128];
		
		//msg sending
		Messages* messages;
		Message* message;
		Instruction* instruction;
		Action* action;
		FlowMod* flowMod;
		GroupMod* groupMod;
		ActionBucket* actionBucket;
		
		//init
		char	        svc_node_name[32]; // to get the address of a node
		
		//update_neighbour, update_flow, remote_interaction
		Ici* ici_ptr_temp = OPC_NIL;
		/* End of Temporary Variables */


		FSM_ENTER ("YAO_CTRL_UNIT")

		FSM_BLOCK_SWITCH
			{
			/*---------------------------------------------------------*/
			/** state (init) enter executives **/
			FSM_STATE_ENTER_FORCED_NOLABEL (0, "init", "YAO_CTRL_UNIT [init enter execs]")
				FSM_PROFILE_SECTION_IN ("YAO_CTRL_UNIT [init enter execs]", state0_enter_exec)
				{
				Boolean isCtrlSrc = OPC_FALSE;
				
				//op_prg_odb_print_minor("init",OPC_NIL);
				
				//get id
				my_objid = op_id_self();
				my_node_id = op_topo_parent (my_objid);
				dataPlane_objid = op_id_from_name(my_node_id, OPC_OBJTYPE_QUEUE, "phd_ip");
				op_ima_obj_attr_get (my_node_id, "name", svc_node_name);
				my_node_addr = get_sufix_from_name_IP_COPY__YAO_CTRL_PLANE(svc_node_name);
				
				srand((unsigned) time(NULL)); // use time as seed
				
				/*
				//Node1 sets Ctrl_src randomly
				if (my_node_addr == 1)
				{
					char str[8];
					int subnetwork_id;
					int node_id;
					int node_addr;
					
					node_addr = rand()%FN_NUM + 1 ; //
					printf("The Ctrl_src is node%d\n", node_addr);
				
					sprintf(str, "node_%d" , node_addr);
					subnetwork_id = op_topo_parent (my_node_id);
					node_id = op_id_from_name (subnetwork_id, OPC_OBJTYPE_NODE_MOB, str);
					op_ima_obj_attr_set_toggle (node_id, "Ctrl_src", OPC_TRUE);
				}
				*/
				
				
				//init global variables
				nexthopCategory_list = op_prg_list_create();
				neighbour_list = op_prg_list_create();
				neighbour_maintainance_list = op_prg_list_create();
				C2PME_list = op_prg_list_create();
				port_list = op_prg_list_create();
				conditionField_list = op_prg_list_create();
				pkt4SR_list = op_prg_list_create();
				
				seq_num = 0;
				sink_hello_num = 0;
				
				ctrl_ete_delay_global = op_stat_reg ("Control Plane.End-to-End Delay (seconds)",	OPC_STAT_INDEX_NONE, OPC_STAT_GLOBAL);
				
				op_intrpt_schedule_self ( op_sim_time(), DEFAULT_STRATEGY_CODE);
				op_intrpt_schedule_self ( op_sim_time(), HELLO_CODE);
				op_intrpt_schedule_self ( op_sim_time()+3, INFO_DISPLAY_CODE);
				//op_intrpt_schedule_self ( op_sim_time()+6, UPDATE_FLOW_CODE);
				//op_intrpt_schedule_self ( op_sim_time()+60, UPDATE_STRATEGY_CODE);
				
				
				op_ima_obj_attr_get_toggle (my_node_id, "Ctrl_src", &isCtrlSrc);
				if (my_node_addr == SINK_ADDR)//assume the controller is in the sink address
				//if (isCtrlSrc)
				{
					op_intrpt_schedule_self ( 5, CNC_CODE);
					printf("Node%d scheduled control\n", my_node_addr);
				}
					
				if (op_prg_odb_ltrace_active("ctrl_plane_init"))
				{
					sprintf (msg0, "my_objid is %d, my_node_id is %d, dataPlane_objid is %d",my_objid, my_node_id, dataPlane_objid);
					op_prg_odb_print_minor (msg0,OPC_NIL);
				}
				
				messages = op_prg_mem_alloc(sizeof(Messages));
				messages->message_list = op_prg_list_create();
				
				/*
				//new ofp_flow_mod msg
				flowMod = op_prg_mem_alloc(sizeof(FlowMod));
				flowMod->command = OFPFC_ADD;
				flowMod->table_id = 0;
				flowMod->priority = 1;
				flowMod->matchFields = op_prg_mem_alloc(sizeof(MatchFields));
				flowMod->instructions = op_prg_mem_alloc(sizeof(Instructions));
				flowMod->matchFields->wildcard[IP_SRC] = SET;
				flowMod->matchFields->wildcard[IP_DST] = SET;
				flowMod->matchFields->matchField[IP_BEFORE_LAST_HOP] = my_node_addr;
				flowMod->matchFields->wildcard[MAC_SRC] = SET;
				flowMod->matchFields->wildcard[MAC_DST] = SET;
				flowMod->instructions->instruction_list = op_prg_list_create();
				//new instruction
				instruction = op_prg_mem_alloc(sizeof(Instruction));
				instruction->ofp_instruction_type = OFPIT_CLEAR_ACTIONS;
				instruction->action_list = OPC_NIL;
				op_prg_list_insert(flowMod->instructions->instruction_list,instruction,OPC_LISTPOS_TAIL);		
				//new instruction
				instruction = op_prg_mem_alloc(sizeof(Instruction));
				instruction->ofp_instruction_type = OFPIT_GOTO_TABLE;
				instruction->action_list = OPC_NIL;
				instruction->table_id = MAX_FLOWTABLE_SIZE;
				op_prg_list_insert(flowMod->instructions->instruction_list,instruction,OPC_LISTPOS_TAIL);
				//new message
				message = op_prg_mem_alloc(sizeof(Message));
				message->type = OFPT_FLOW_MOD;
				message->contents = flowMod;
				op_prg_list_insert(messages->message_list,message,OPC_LISTPOS_TAIL);
				*/
				
				//new ofp_flow_mod msg
				flowMod = op_prg_mem_alloc(sizeof(FlowMod));
				flowMod->command = OFPFC_ADD;
				flowMod->table_id = 0;
				flowMod->priority = 0;
				flowMod->matchFields = op_prg_mem_alloc(sizeof(MatchFields));
				flowMod->instructions = op_prg_mem_alloc(sizeof(Instructions));
				flowMod->matchFields->wildcard[IP_SRC] = SET;
				flowMod->matchFields->wildcard[IP_DST] = SET;
				flowMod->matchFields->wildcard[IP_BEFORE_LAST_HOP] = SET;
				flowMod->matchFields->wildcard[MAC_SRC] = SET;
				flowMod->matchFields->wildcard[MAC_DST] = SET;
				flowMod->instructions->instruction_list = op_prg_list_create();
				//new instruction //clear actions
				instruction = op_prg_mem_alloc(sizeof(Instruction));
				instruction->ofp_instruction_type = OFPIT_CLEAR_ACTIONS;
				instruction->action_list = OPC_NIL;
				op_prg_list_insert(flowMod->instructions->instruction_list,instruction,OPC_LISTPOS_TAIL);		
				/*
				//new instruction //ask ctrl
				instruction = op_prg_mem_alloc(sizeof(Instruction));
				instruction->ofp_instruction_type = OFPIT_WRITE_ACTIONS;
				instruction->action_list = op_prg_list_create();
				op_prg_list_insert(flowMod->instructions->instruction_list,instruction,OPC_LISTPOS_TAIL);		
				//new action
				action = op_prg_mem_alloc(sizeof(Action));
				action->ofp_action_type = OUTPUT_CTRL;
				action->associatedData = OPC_NIL;
				op_prg_list_insert(instruction->action_list,action,OPC_LISTPOS_TAIL);
				*/
				//new instruction
				instruction = op_prg_mem_alloc(sizeof(Instruction));
				instruction->ofp_instruction_type = OFPIT_GOTO_TABLE;
				instruction->action_list = OPC_NIL;
				instruction->table_id = MAX_FLOWTABLE_SIZE;
				op_prg_list_insert(flowMod->instructions->instruction_list,instruction,OPC_LISTPOS_TAIL);
				
				//new message
				message = op_prg_mem_alloc(sizeof(Message));
				message->type = OFPT_FLOW_MOD;
				message->contents = flowMod;
				op_prg_list_insert(messages->message_list,message,OPC_LISTPOS_TAIL);
				
				//new ofp_flow_mod msg
				flowMod = op_prg_mem_alloc(sizeof(FlowMod));
				flowMod->command = OFPFC_ADD;
				flowMod->table_id = 1;
				flowMod->priority = 0;
				flowMod->matchFields = op_prg_mem_alloc(sizeof(MatchFields));
				flowMod->instructions = op_prg_mem_alloc(sizeof(Instructions));
				flowMod->matchFields->wildcard[IP_SRC] = SET;
				flowMod->matchFields->wildcard[IP_DST] = SET;
				flowMod->matchFields->wildcard[IP_BEFORE_LAST_HOP] = SET;
				flowMod->matchFields->wildcard[MAC_SRC] = SET;
				flowMod->matchFields->wildcard[MAC_DST] = SET;
				flowMod->instructions->instruction_list = op_prg_list_create();
				//new instruction
				instruction = op_prg_mem_alloc(sizeof(Instruction));
				instruction->ofp_instruction_type = OFPIT_WRITE_ACTIONS;
				instruction->action_list = op_prg_list_create();
				op_prg_list_insert(flowMod->instructions->instruction_list,instruction,OPC_LISTPOS_TAIL);		
				//new action
				action = op_prg_mem_alloc(sizeof(Action));
				action->ofp_action_type = SET_BEFORELASTHOP;
				action->associatedData = OPC_NIL;
				op_prg_list_insert(instruction->action_list,action,OPC_LISTPOS_TAIL);
				//new action
				action = op_prg_mem_alloc(sizeof(Action));
				action->ofp_action_type = SET_LASTHOP;
				action->associatedData = OPC_NIL;
				op_prg_list_insert(instruction->action_list,action,OPC_LISTPOS_TAIL);
				//new action
				action = op_prg_mem_alloc(sizeof(Action));
				action->ofp_action_type = OUTPUT_LOWER;
				action->associatedData = OPC_NIL;
				op_prg_list_insert(instruction->action_list,action,OPC_LISTPOS_TAIL);
				//new message
				message = op_prg_mem_alloc(sizeof(Message));
				message->type = OFPT_FLOW_MOD;
				message->contents = flowMod;
				op_prg_list_insert(messages->message_list,message,OPC_LISTPOS_TAIL);
				
				ici_ptr_temp = op_ici_create("yao_ici");
				op_ici_attr_set (ici_ptr_temp, "msgs",  messages);
				op_ici_install (ici_ptr_temp);
				
				op_intrpt_schedule_remote (op_sim_time(), DATAPATH_CTRL_CODE, dataPlane_objid);
				}
				FSM_PROFILE_SECTION_OUT (state0_enter_exec)

			/** state (init) exit executives **/
			FSM_STATE_EXIT_FORCED (0, "init", "YAO_CTRL_UNIT [init exit execs]")


			/** state (init) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "init", "idle", "tr_0", "YAO_CTRL_UNIT [init -> idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (idle) enter executives **/
			FSM_STATE_ENTER_UNFORCED (1, "idle", state1_enter_exec, "YAO_CTRL_UNIT [idle enter execs]")

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (3,"YAO_CTRL_UNIT")


			/** state (idle) exit executives **/
			FSM_STATE_EXIT_UNFORCED (1, "idle", "YAO_CTRL_UNIT [idle exit execs]")


			/** state (idle) transition processing **/
			FSM_PROFILE_SECTION_IN ("YAO_CTRL_UNIT [idle trans conditions]", state1_trans_conds)
			FSM_INIT_COND (DEFAULT_STRATEGY_INTRPT)
			FSM_TEST_COND (INFO_DISPLAY_INTRPT)
			FSM_TEST_COND (REMOTE_INTRPT)
			FSM_TEST_COND (UPDATE_FLOW_INTRPT)
			FSM_TEST_COND (HELLO_INTRPT)
			FSM_TEST_COND (CNC_INTRPT)
			FSM_TEST_COND (PKT_ARRIVE)
			FSM_TEST_LOGIC ("idle")
			FSM_PROFILE_SECTION_OUT (state1_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 4, state4_enter_exec, ;, "DEFAULT_STRATEGY_INTRPT", "", "idle", "default_strategy", "tr_5", "YAO_CTRL_UNIT [idle -> default_strategy : DEFAULT_STRATEGY_INTRPT / ]")
				FSM_CASE_TRANSIT (1, 5, state5_enter_exec, ;, "INFO_DISPLAY_INTRPT", "", "idle", "info_display", "tr_7", "YAO_CTRL_UNIT [idle -> info_display : INFO_DISPLAY_INTRPT / ]")
				FSM_CASE_TRANSIT (2, 6, state6_enter_exec, ;, "REMOTE_INTRPT", "", "idle", "remote_interaction", "tr_11", "YAO_CTRL_UNIT [idle -> remote_interaction : REMOTE_INTRPT / ]")
				FSM_CASE_TRANSIT (3, 3, state3_enter_exec, ;, "UPDATE_FLOW_INTRPT", "", "idle", "update_flow", "tr_13", "YAO_CTRL_UNIT [idle -> update_flow : UPDATE_FLOW_INTRPT / ]")
				FSM_CASE_TRANSIT (4, 2, state2_enter_exec, ;, "HELLO_INTRPT", "", "idle", "Hello", "tr_14", "YAO_CTRL_UNIT [idle -> Hello : HELLO_INTRPT / ]")
				FSM_CASE_TRANSIT (5, 7, state7_enter_exec, ;, "CNC_INTRPT", "", "idle", "cnc", "tr_15", "YAO_CTRL_UNIT [idle -> cnc : CNC_INTRPT / ]")
				FSM_CASE_TRANSIT (6, 8, state8_enter_exec, ;, "PKT_ARRIVE", "", "idle", "pkt_handling_in_ctrl", "tr_17", "YAO_CTRL_UNIT [idle -> pkt_handling_in_ctrl : PKT_ARRIVE / ]")
				}
				/*---------------------------------------------------------*/



			/** state (Hello) enter executives **/
			FSM_STATE_ENTER_FORCED (2, "Hello", state2_enter_exec, "YAO_CTRL_UNIT [Hello enter execs]")
				FSM_PROFILE_SECTION_IN ("YAO_CTRL_UNIT [Hello enter execs]", state2_enter_exec)
				{
				
				
				//op_sim_end("Force simulation end @ hello STATE", "", "", "");
				
				Ici* hello_ici_ptr = OPC_NIL;
				Packet*			hello_pkt = OPC_NIL;
				int		neighbourNum;
				
				neighbourNum = op_prg_list_size(neighbour_list);
				
				hello_pkt = op_pk_create_fmt("DSDV_hello");
				op_pk_nfd_set ( hello_pkt,"Type", HELLO_PK_TYPE);
				op_pk_nfd_set ( hello_pkt,"Src", my_node_addr );
				op_pk_nfd_set ( hello_pkt,"Sequence_num", NOT_AVAILABLE);//local_sequence
				op_pk_nfd_set ( hello_pkt,"Neighbour_num", neighbourNum);
				op_pk_nfd_set ( hello_pkt,"SinkHello_num", sink_hello_num);
				//hello_pk_num++;
				
				//not sure for what usage
				hello_ici_ptr = op_ici_create("dsdv_ip_to_mac_ici");
				op_ici_attr_set(hello_ici_ptr,"type",1);
				op_ici_attr_set(hello_ici_ptr,"subtype",HELLO_PK_TYPE);
				op_ici_attr_set (hello_ici_ptr, "NextHop", BROADCAST_ADDR);
				op_pk_ici_set(hello_pkt, hello_ici_ptr);
				
				
				op_pk_send (hello_pkt, OUTPUT_STRM);
				//op_ici_destroy(hello_ici_ptr);
				
				//sprintf (msg0, "I'm node %d sent HELLO packet",my_node_addr);
				//op_prg_odb_print_minor (msg0,OPC_NIL);
				
				/////op_prg_odb_bkpt("h");
				
				
				//if (op_sim_time() < 10)
				{
					op_intrpt_schedule_self ( op_sim_time() + HELLO_INTERVAL, HELLO_CODE );
				}
				}
				FSM_PROFILE_SECTION_OUT (state2_enter_exec)

			/** state (Hello) exit executives **/
			FSM_STATE_EXIT_FORCED (2, "Hello", "YAO_CTRL_UNIT [Hello exit execs]")


			/** state (Hello) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "Hello", "idle", "tr_2", "YAO_CTRL_UNIT [Hello -> idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (update_flow) enter executives **/
			FSM_STATE_ENTER_FORCED (3, "update_flow", state3_enter_exec, "YAO_CTRL_UNIT [update_flow enter execs]")
				FSM_PROFILE_SECTION_IN ("YAO_CTRL_UNIT [update_flow enter execs]", state3_enter_exec)
				{
				QualityOfService* QoS = OPC_NIL;
				ForwardingPara* forwardingPara = OPC_NIL;
				MatchFields* matchFields = OPC_NIL;
				
				ici_ptr_temp = op_intrpt_ici();
				if (ici_ptr_temp != OPC_NIL)
				{
				 if(op_ici_attr_exists(ici_ptr_temp,"matchFields"))
					op_ici_attr_get (ici_ptr_temp, "matchFields", &matchFields);
					//destroy ici
				}
				else
				{
					op_prg_odb_print_minor("",OPC_NIL);
					op_sim_end("Force simulation end @ update_flow", "", "", "");		
				}	
				
				//should convert according background information such as pkt type
				QoS = op_prg_mem_alloc(sizeof(QualityOfService));
				QoS->delayTolerant = OPC_TRUE;
				
				messages = op_prg_mem_alloc(sizeof(Messages));
				messages->message_list = op_prg_list_create();
				
				
				
				//////////////This is a core function for strategy implementation
				forwardingPara = getFwdPara(matchFields, QoS);
				
				if (forwardingPara == OPC_NIL)
				{
					//op_prg_odb_print_minor("forwardingPara == OPC_NIL",OPC_NIL);
					op_sim_end("Force simulation end because cannot find forwarding parameter", "", "", "");	
				}	
				else
				{
					//op_prg_odb_print_minor("",OPC_NIL);
					//printf("Node(%2d) nexthop candidates:", my_node_addr);
					//print_int_list_copy__YAO_CTRL_UNIT(forwardingPara->nexthopCandidate_list);
				
					if (op_prg_list_size(forwardingPara->nexthopCandidate_list) == 1)
					{
						int nexthop = *(int*)op_prg_list_access(forwardingPara->nexthopCandidate_list, OPC_LISTPOS_HEAD);
						char temp_neighbour[3],*temp_name;
						Objid finalId;
						double my_y_position_now,my_x_position_now,neigh_x_position,neigh_y_position;
						itoa(nexthop,temp_neighbour,10);
						op_ima_obj_attr_get(my_node_id,"x position", &my_x_position_now);
				        op_ima_obj_attr_get(my_node_id,"y position", &my_y_position_now);
						temp_name=(char *)op_prg_mem_alloc(sizeof("top.Campus Network.node_"));
						strcpy(temp_name,"top.Campus Network.node_");
						strcat(temp_name,temp_neighbour);
						finalId=op_id_from_hierarchical_name(temp_name);
						op_ima_obj_attr_get(finalId,"x position", &neigh_x_position);
						op_ima_obj_attr_get(finalId,"y position", &neigh_y_position);
						r_distance=sqrt((neigh_x_position-my_x_position_now)*(neigh_x_position-my_x_position_now)+(neigh_y_position-my_y_position_now)*(neigh_y_position-my_y_position_now));
						//printf("distance is %f\n",r_distance);
						//new ofp_flow_mod msg
						flowMod = op_prg_mem_alloc(sizeof(FlowMod));
						flowMod->command = OFPFC_MODIFY_STRICT;
						flowMod->table_id = 0;
						flowMod->priority = 0;
						flowMod->matchFields = op_prg_mem_alloc(sizeof(MatchFields));
						flowMod->instructions = op_prg_mem_alloc(sizeof(Instructions));
						flowMod->matchFields->wildcard[IP_SRC] = SET;
						flowMod->matchFields->wildcard[IP_DST] = SET;
						flowMod->matchFields->wildcard[IP_BEFORE_LAST_HOP] = SET;
						flowMod->matchFields->wildcard[MAC_SRC] = SET;
						flowMod->matchFields->wildcard[MAC_DST] = SET;
						flowMod->instructions->instruction_list = op_prg_list_create();
						//new instruction
						instruction = op_prg_mem_alloc(sizeof(Instruction));
						instruction->ofp_instruction_type = OFPIT_APPLY_ACTIONS;
						instruction->action_list = op_prg_list_create();
						op_prg_list_insert(flowMod->instructions->instruction_list,instruction,OPC_LISTPOS_TAIL);		
						//new action
						action = op_prg_mem_alloc(sizeof(Action));
						action->ofp_action_type = SET_NEXTHOP;
						action->associatedData = op_prg_mem_alloc(sizeof(AssociatedData));
						action->associatedData->nexthop = nexthop;
						action->associatedData->distance =r_distance;
						//printf("distance is %f\n",action->associatedData->distance);
						op_prg_list_insert(instruction->action_list,action,OPC_LISTPOS_TAIL);
						//new message
						message = op_prg_mem_alloc(sizeof(Message));
						message->type = OFPT_FLOW_MOD;
						message->contents = flowMod;
						op_prg_list_insert(messages->message_list,message,OPC_LISTPOS_TAIL);
					}
					else if (op_prg_list_size(forwardingPara->nexthopCandidate_list) > 1)
					{
					
						//new groupMod msg
						groupMod = op_prg_mem_alloc(sizeof(GroupMod));
						groupMod->command = OFPGC_MODIFY;
						groupMod->type = OFPGT_SELECT;
						groupMod->group_id = 0;
						groupMod->actionBuckets = op_prg_mem_alloc(sizeof(ActionBuckets));
						groupMod->actionBuckets->actionBucket_list = op_prg_list_create();
						
						while (op_prg_list_size(forwardingPara->nexthopCandidate_list) > 0)
						{
							int* int_ptr_temp = OPC_NIL;
									
							int_ptr_temp = (int*) op_prg_list_remove(forwardingPara->nexthopCandidate_list, OPC_LISTPOS_HEAD);
					
							//new actionBucket
							actionBucket = op_prg_mem_alloc(sizeof(ActionBucket));
							actionBucket->action_list = op_prg_list_create();
							op_prg_list_insert(groupMod->actionBuckets->actionBucket_list,actionBucket,OPC_LISTPOS_TAIL);		
							//new action
							action = op_prg_mem_alloc(sizeof(Action));
							action->ofp_action_type = SET_NEXTHOP;
							action->associatedData = op_prg_mem_alloc(sizeof(AssociatedData));
							action->associatedData->nexthop = *int_ptr_temp;
							op_prg_list_insert(actionBucket->action_list,action,OPC_LISTPOS_TAIL);	
							
							op_prg_mem_free(int_ptr_temp);
						}	
						
						//new message
						message = op_prg_mem_alloc(sizeof(Message));
						message->type = OFPT_GROUP_MOD;
						message->contents = groupMod;
						op_prg_list_insert(messages->message_list,message,OPC_LISTPOS_TAIL);
						
						
						//new ofp_flow_mod msg
						flowMod = op_prg_mem_alloc(sizeof(FlowMod));
						flowMod->command = OFPFC_MODIFY_STRICT;
						flowMod->table_id = 0;
						flowMod->priority = 0;
						flowMod->matchFields = op_prg_mem_alloc(sizeof(MatchFields));
						flowMod->instructions = op_prg_mem_alloc(sizeof(Instructions));
						flowMod->matchFields->wildcard[IP_SRC] = SET;
						flowMod->matchFields->wildcard[IP_DST] = SET;
						flowMod->matchFields->wildcard[IP_BEFORE_LAST_HOP] = SET;
						flowMod->matchFields->wildcard[MAC_SRC] = SET;
						flowMod->matchFields->wildcard[MAC_DST] = SET;
						flowMod->instructions->instruction_list = op_prg_list_create();
						//new instruction
						instruction = op_prg_mem_alloc(sizeof(Instruction));
						instruction->ofp_instruction_type = OFPIT_APPLY_ACTIONS;
						instruction->action_list = op_prg_list_create();
						op_prg_list_insert(flowMod->instructions->instruction_list,instruction,OPC_LISTPOS_TAIL);		
						//new action
						action = op_prg_mem_alloc(sizeof(Action));
						action->ofp_action_type = GROUP;
						action->associatedData = op_prg_mem_alloc(sizeof(AssociatedData));
						action->associatedData->group_id = 0;
						op_prg_list_insert(instruction->action_list,action,OPC_LISTPOS_TAIL);
						//new message
						message = op_prg_mem_alloc(sizeof(Message));
						message->type = OFPT_FLOW_MOD;
						message->contents = flowMod;
						op_prg_list_insert(messages->message_list,message,OPC_LISTPOS_TAIL);
							
					}
					else if (op_prg_list_size(forwardingPara->nexthopCandidate_list) == 0)
					{
						//new ofp_flow_mod msg
						flowMod = op_prg_mem_alloc(sizeof(FlowMod));
						flowMod->command = OFPFC_MODIFY_STRICT;
						flowMod->table_id = 0;
						flowMod->priority = 0;
						flowMod->matchFields = op_prg_mem_alloc(sizeof(MatchFields));
						flowMod->instructions = op_prg_mem_alloc(sizeof(Instructions));
						flowMod->matchFields->wildcard[IP_SRC] = SET;
						flowMod->matchFields->wildcard[IP_DST] = SET;
						flowMod->matchFields->wildcard[IP_BEFORE_LAST_HOP] = SET;
						flowMod->matchFields->wildcard[MAC_SRC] = SET;
						flowMod->matchFields->wildcard[MAC_DST] = SET;
						flowMod->instructions->instruction_list = op_prg_list_create();
						//new instruction
						instruction = op_prg_mem_alloc(sizeof(Instruction));
						instruction->ofp_instruction_type = OFPIT_CLEAR_ACTIONS;
						instruction->action_list = OPC_NIL;
						op_prg_list_insert(flowMod->instructions->instruction_list,instruction,OPC_LISTPOS_TAIL);		
						//new instruction
						instruction = op_prg_mem_alloc(sizeof(Instruction));
						instruction->ofp_instruction_type = OFPIT_GOTO_TABLE;
						instruction->action_list = OPC_NIL;
						instruction->table_id = MAX_FLOWTABLE_SIZE;
						op_prg_list_insert(flowMod->instructions->instruction_list,instruction,OPC_LISTPOS_TAIL);		
						//new message
						message = op_prg_mem_alloc(sizeof(Message));
						message->type = OFPT_FLOW_MOD;
						message->contents = flowMod;
						op_prg_list_insert(messages->message_list,message,OPC_LISTPOS_TAIL);
				
					}
					else
					{
						op_prg_odb_print_minor("",OPC_NIL);
						op_sim_end("Force simulation end @ update_flow", "", "", "");		
					}
				
				}
				// free forwardingPara
				op_prg_list_free(forwardingPara->nexthopCandidate_list);
				//op_prg_mem_free(forwardingPara->nexthopCandidate_list);
				op_prg_mem_free(forwardingPara);
				// free matchFields
				
				
				ici_ptr_temp = op_ici_create("yao_ici");
				op_ici_attr_set (ici_ptr_temp, "msgs",  messages);
				op_ici_install (ici_ptr_temp);
				
				op_intrpt_schedule_remote (op_sim_time(), DATAPATH_CTRL_CODE, dataPlane_objid);
				
				}
				FSM_PROFILE_SECTION_OUT (state3_enter_exec)

			/** state (update_flow) exit executives **/
			FSM_STATE_EXIT_FORCED (3, "update_flow", "YAO_CTRL_UNIT [update_flow exit execs]")


			/** state (update_flow) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "update_flow", "idle", "tr_4", "YAO_CTRL_UNIT [update_flow -> idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (default_strategy) enter executives **/
			FSM_STATE_ENTER_FORCED (4, "default_strategy", state4_enter_exec, "YAO_CTRL_UNIT [default_strategy enter execs]")
				FSM_PROFILE_SECTION_IN ("YAO_CTRL_UNIT [default_strategy enter execs]", state4_enter_exec)
				{
				ConditionField* conditionField = OPC_NIL;
				Port* port = OPC_NIL;
				int* int_ptr = OPC_NIL;
				NexthopCategory* nexthopCategory = OPC_NIL;
				int i;
				
				//define a condition field
				conditionField = op_prg_mem_alloc(sizeof(ConditionField));
				conditionField->fieldLabel = TOLERANCE_FIELD;
				conditionField->definedCondition_list = op_prg_list_create();
				conditionField->realCondition_list = op_prg_list_create();
				op_prg_list_insert(conditionField_list, conditionField, OPC_LISTPOS_TAIL);
				
				//define a condition
				for (i=0; i<op_prg_list_size(conditionField_list); i++)
				{
					conditionField = (ConditionField*)op_prg_list_access(conditionField_list, i);
					if (conditionField->fieldLabel == TOLERANCE_FIELD)
					{
						//should check if the subLabel exists firstly
						int* subLabel_ptr = op_prg_mem_alloc(sizeof(int));
						
						*subLabel_ptr = DELAY_SUBFIELD;
						op_prg_list_insert(conditionField->definedCondition_list, subLabel_ptr, OPC_LISTPOS_TAIL);
					}
				}
				
				
				//define default port (basic broadcast)
				port = op_prg_mem_alloc(sizeof(Port));
				port->portLabel = DEFAULT_PORT;
				port->candidateMaxNum = 1;
				port->categoryLabel_list = OPC_NIL;
				port->forwardingPattern = BROADCAST_FP;
				op_prg_list_insert(port_list, port, OPC_LISTPOS_TAIL);
				
				//define a new port (gossip)
				port = op_prg_mem_alloc(sizeof(Port));
				port->portLabel = GOSSIP_PORT;
				port->candidateMaxNum = 5;
				port->categoryLabel_list = op_prg_list_create();
				int_ptr = op_prg_mem_alloc(sizeof(int));
				*int_ptr = SHORTPATH_NC;
				op_prg_list_insert(port->categoryLabel_list, int_ptr, OPC_LISTPOS_TAIL);
				int_ptr = op_prg_mem_alloc(sizeof(int));
				*int_ptr = ANY_NC;
				op_prg_list_insert(port->categoryLabel_list, int_ptr, OPC_LISTPOS_TAIL);
				port->forwardingPattern = UNICAST_FP;
				op_prg_list_insert(port_list, port, OPC_LISTPOS_TAIL);
				
				//define a new port (For Guo)
				port = op_prg_mem_alloc(sizeof(Port));
				port->portLabel = GUO_PORT;
				port->candidateMaxNum = 1;
				port->categoryLabel_list = op_prg_list_create();
				int_ptr = op_prg_mem_alloc(sizeof(int));
				*int_ptr = GUO_NC;
				op_prg_list_insert(port->categoryLabel_list, int_ptr, OPC_LISTPOS_TAIL);
				port->forwardingPattern = UNICAST_FP;
				op_prg_list_insert(port_list, port, OPC_LISTPOS_TAIL);
				
				//define nexthop category
				nexthopCategory = op_prg_mem_alloc(sizeof(NexthopCategory));
				nexthopCategory->categoryLabel = ANY_NC;
				nexthopCategory->node_list = op_prg_list_create();
				op_prg_list_insert(nexthopCategory_list,nexthopCategory,OPC_LISTPOS_TAIL);
				
				nexthopCategory = op_prg_mem_alloc(sizeof(NexthopCategory));
				nexthopCategory->categoryLabel = SHORTPATH_NC;
				nexthopCategory->node_list = op_prg_list_create();
				op_prg_list_insert(nexthopCategory_list,nexthopCategory,OPC_LISTPOS_TAIL);
				
				nexthopCategory = op_prg_mem_alloc(sizeof(NexthopCategory));
				nexthopCategory->categoryLabel = GUO_NC;
				nexthopCategory->node_list = op_prg_list_create();
				op_prg_list_insert(nexthopCategory_list,nexthopCategory,OPC_LISTPOS_TAIL);
				}
				FSM_PROFILE_SECTION_OUT (state4_enter_exec)

			/** state (default_strategy) exit executives **/
			FSM_STATE_EXIT_FORCED (4, "default_strategy", "YAO_CTRL_UNIT [default_strategy exit execs]")


			/** state (default_strategy) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "default_strategy", "idle", "tr_6", "YAO_CTRL_UNIT [default_strategy -> idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (info_display) enter executives **/
			FSM_STATE_ENTER_FORCED (5, "info_display", state5_enter_exec, "YAO_CTRL_UNIT [info_display enter execs]")
				FSM_PROFILE_SECTION_IN ("YAO_CTRL_UNIT [info_display enter execs]", state5_enter_exec)
				{
				printf("Node(%2d) neighbours:", my_node_addr);
				print_int_list_copy__YAO_CTRL_UNIT(neighbour_list);
				}
				FSM_PROFILE_SECTION_OUT (state5_enter_exec)

			/** state (info_display) exit executives **/
			FSM_STATE_EXIT_FORCED (5, "info_display", "YAO_CTRL_UNIT [info_display exit execs]")


			/** state (info_display) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "info_display", "idle", "tr_8", "YAO_CTRL_UNIT [info_display -> idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (remote_interaction) enter executives **/
			FSM_STATE_ENTER_FORCED (6, "remote_interaction", state6_enter_exec, "YAO_CTRL_UNIT [remote_interaction enter execs]")
				FSM_PROFILE_SECTION_IN ("YAO_CTRL_UNIT [remote_interaction enter execs]", state6_enter_exec)
				{
				int intrpt_code;
				
				intrpt_code = op_intrpt_code();
				ici_ptr_temp = op_intrpt_ici();
				op_ici_install (ici_ptr_temp);
				
				/*
				op_prg_odb_print_minor("", OPC_NIL);
				printf("intrpt_code is %d\n", intrpt_code);
				op_sim_end("", "", "", "");
				*/
				
				switch(intrpt_code)
				{
					
					case REMOTE_PKT_IN_CODE:
					{			
						op_intrpt_schedule_self ( op_sim_time(), UPDATE_FLOW_CODE);
						op_intrpt_schedule_remote (op_sim_time(), REMOTE_PKT_OUT_CODE, dataPlane_objid);
						break;
					}
					
					case REMOTE_CTRL_RCV_CODE:
					{
						op_intrpt_schedule_self ( op_sim_time(), UPDATE_STRATEGY_CODE);
						break;
					}
				
					case REMOTE_TIME_CODE:
					{ op_ici_attr_get (ici_ptr_temp, "No_seq", &no_seq);
					   op_ici_attr_get (ici_ptr_temp, "recv_time", &recv_time);
					  // printf("number is %d,time is %f\n",no_seq,recv_time);
					   op_ici_destroy(ici_ptr_temp);
					   break;
					}
					
					default:
					{
						op_prg_odb_print_minor("Unknown remote interruption", OPC_NIL);
						printf("intrpt_code is %d\n", intrpt_code);
						op_sim_end("", "", "", "");
						break;
					}
				
				}
				}
				FSM_PROFILE_SECTION_OUT (state6_enter_exec)

			/** state (remote_interaction) exit executives **/
			FSM_STATE_EXIT_FORCED (6, "remote_interaction", "YAO_CTRL_UNIT [remote_interaction exit execs]")


			/** state (remote_interaction) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "remote_interaction", "idle", "tr_12", "YAO_CTRL_UNIT [remote_interaction -> idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (cnc) enter executives **/
			FSM_STATE_ENTER_FORCED (7, "cnc", state7_enter_exec, "YAO_CTRL_UNIT [cnc enter execs]")
				FSM_PROFILE_SECTION_IN ("YAO_CTRL_UNIT [cnc enter execs]", state7_enter_exec)
				{
				Condition2PortMapEntry* condition2PortMapEntry = OPC_NIL;
				TargetCondition* targetCondition = OPC_NIL;
				int* int_ptr = OPC_NIL;
				Ici* ici_ptr_temp = OPC_NIL;
				Packet*	pkt_ptr_temp = OPC_NIL;
				int next_hop;
				int dst_node;
				List* targetNodes_list = OPC_NIL;
				
				//define a condition2PortMapEntry
				condition2PortMapEntry = op_prg_mem_alloc(sizeof(Condition2PortMapEntry));
				condition2PortMapEntry->portLabel = GUO_PORT;//GOSSIP_PORT;//
				condition2PortMapEntry->targetCondition_list = op_prg_list_create();
				//define a target condition
				targetCondition = op_prg_mem_alloc(sizeof(TargetCondition));
				targetCondition->fieldLabel = TOLERANCE_FIELD;
				targetCondition->subfieldLabel_list = op_prg_list_create();
				int_ptr = op_prg_mem_alloc(sizeof(int));
				*int_ptr = DELAY_SUBFIELD;
				op_prg_list_insert(targetCondition->subfieldLabel_list, int_ptr, OPC_LISTPOS_TAIL);
				op_prg_list_insert(condition2PortMapEntry->targetCondition_list, targetCondition, OPC_LISTPOS_TAIL);
				
				seq_num++;
				
				//printf("%d\n", condition2PortMapEntry->portLabel);
				
				/*
				//get target nodes list
				targetNodes_list = getTargetNodesList(6,5);
				printf("The target nodes list is:");
				print_int_list_copy__YAO_CTRL_UNIT(targetNodes_list);
				//set primary and secondary receivers
				dst_node = getPrimaryReceiver(targetNodes_list);// the remaining nodes in list are secondary receivers
				printf("The primary receiver node is %d\n", dst_node);
				printf("The  secondary receivers list is:");
				print_int_list_copy__YAO_CTRL_UNIT(targetNodes_list);
				*/
				dst_node = NOT_AVAILABLE;
				targetNodes_list = op_prg_list_create();
				
				//choose next hop
				next_hop = BROADCAST_ADDR;//getNexthop(dst_node);//
				//printf("node%2d choose nexthop node%2d\n", my_node_addr, next_hop);
				
				pkt_ptr_temp = op_pk_create_fmt("YAO_ctrl_pkt");
				op_pk_nfd_set ( pkt_ptr_temp,"Type", CTRL_PK_TYPE);
				op_pk_nfd_set ( pkt_ptr_temp,"Src", my_node_addr);
				op_pk_nfd_set ( pkt_ptr_temp,"Dst", dst_node);
				op_pk_nfd_set ( pkt_ptr_temp,"before_last_hop", my_node_addr);
				op_pk_nfd_set ( pkt_ptr_temp,"last_hop", my_node_addr);
				op_pk_nfd_set ( pkt_ptr_temp,"next_hop", next_hop);
				op_pk_nfd_set ( pkt_ptr_temp,"TTL", 6);
				op_pk_nfd_set ( pkt_ptr_temp,"Sequence_num", seq_num);	
				op_pk_nfd_set_ptr (pkt_ptr_temp, "C2PM_entry", condition2PortMapEntry, op_prg_mem_copy_create, op_prg_mem_free, sizeof (Condition2PortMapEntry));
				op_pk_nfd_set_ptr (pkt_ptr_temp, "secondary_receivers_list", targetNodes_list, op_prg_mem_copy_create, op_prg_mem_free, sizeof (List));
				
				ici_ptr_temp = op_ici_create("dsdv_ip_to_mac_ici");
				op_ici_attr_set(ici_ptr_temp,"type",1);
				op_ici_attr_set(ici_ptr_temp,"subtype",HELLO_PK_TYPE);
				op_ici_attr_set (ici_ptr_temp, "NextHop", -2);
				op_pk_ici_set(pkt_ptr_temp, ici_ptr_temp);
				
				op_pk_send (pkt_ptr_temp, OUTPUT_STRM);
				
				//printf("Ctrl msg (seq=%d) sent from node%2d t=%f\n", seq_num, my_node_addr, op_sim_time());
				//op_prg_odb_print_minor("CTRL_PKT is created and sent out", OPC_NIL);
				
				
				
				/*
				ici_ptr_temp = op_ici_create("yao_ici");
				//op_ici_attr_set(ici_ptr_temp,"type",2);
				op_ici_attr_set (ici_ptr_temp, "C2PM_entry", condition2PortMapEntry);
				op_ici_attr_set (ici_ptr_temp, "seq_num", seq_num);
				op_ici_install (ici_ptr_temp);
				op_intrpt_schedule_remote (op_sim_time(), REMOTE_CTRL_CODE, dataPlane_objid);
				*/
				
				//op_prg_odb_print_minor("CNC is to update strategy", OPC_NIL);
				
				//op_intrpt_schedule_self ( op_sim_time() + 3, CNC_CODE );
				}
				FSM_PROFILE_SECTION_OUT (state7_enter_exec)

			/** state (cnc) exit executives **/
			FSM_STATE_EXIT_FORCED (7, "cnc", "YAO_CTRL_UNIT [cnc exit execs]")


			/** state (cnc) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "cnc", "idle", "tr_16", "YAO_CTRL_UNIT [cnc -> idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (pkt_handling_in_ctrl) enter executives **/
			FSM_STATE_ENTER_FORCED (8, "pkt_handling_in_ctrl", state8_enter_exec, "YAO_CTRL_UNIT [pkt_handling_in_ctrl enter execs]")
				FSM_PROFILE_SECTION_IN ("YAO_CTRL_UNIT [pkt_handling_in_ctrl enter execs]", state8_enter_exec)
				{
				Packet* pkt_ptr;
				int pk_type;
				
				//op_prg_odb_print_minor("START @ pkt_handling_in_ctrl STATE", OPC_NIL);
					
				pkt_ptr = op_pk_get(INPUT_STRM);
				
				op_pk_nfd_get(pkt_ptr, "Type",  &pk_type);
				
				if (pk_type == HELLO_PK_TYPE)
				{
					helloPktProcessing(pkt_ptr);
				}
				else if (pk_type == CTRL_PK_TYPE)
				{
					ctrlPktProcessing(pkt_ptr);
					//printStrategyList();
				}
				else
				{
					op_prg_odb_print_minor("Unknown pk_type @ CTRL", OPC_NIL);
					op_sim_end("Force simulation end", "", "", "");			
				}
				//op_prg_odb_print_minor("END @ pkt_handling_in_ctrl STATE", OPC_NIL);
				}
				FSM_PROFILE_SECTION_OUT (state8_enter_exec)

			/** state (pkt_handling_in_ctrl) exit executives **/
			FSM_STATE_EXIT_FORCED (8, "pkt_handling_in_ctrl", "YAO_CTRL_UNIT [pkt_handling_in_ctrl exit execs]")


			/** state (pkt_handling_in_ctrl) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "pkt_handling_in_ctrl", "idle", "tr_18", "YAO_CTRL_UNIT [pkt_handling_in_ctrl -> idle : default / ]")
				/*---------------------------------------------------------*/



			}


		FSM_EXIT (0,"YAO_CTRL_UNIT")
		}
	}




void
_op_YAO_CTRL_UNIT_diag (OP_SIM_CONTEXT_ARG_OPT)
	{
	/* No Diagnostic Block */
	}




void
_op_YAO_CTRL_UNIT_terminate (OP_SIM_CONTEXT_ARG_OPT)
	{

	FIN_MT (_op_YAO_CTRL_UNIT_terminate ())


	/* No Termination Block */

	Vos_Poolmem_Dealloc (op_sv_ptr);

	FOUT
	}


/* Undefine shortcuts to state variables to avoid */
/* syntax error in direct access to fields of */
/* local variable prs_ptr in _op_YAO_CTRL_UNIT_svar function. */
#undef my_objid
#undef my_node_id
#undef dataPlane_objid
#undef neighbour_list
#undef nexthopCategory_list
#undef C2PME_list
#undef port_list
#undef conditionField_list
#undef my_node_addr
#undef seq_num
#undef ctrl_ete_delay_global
#undef neighbour_maintainance_list
#undef pkt4SR_list
#undef sink_hello_num
#undef num_absorb_node
#undef sink_objid
#undef r_distance
#undef successrate
#undef recv_time
#undef userighthand
#undef dist_neigh_to_sour
#undef no_seq

#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE

#define FIN_PREAMBLE_DEC
#define FIN_PREAMBLE_CODE

VosT_Obtype
_op_YAO_CTRL_UNIT_init (int * init_block_ptr)
	{
	VosT_Obtype obtype = OPC_NIL;
	FIN_MT (_op_YAO_CTRL_UNIT_init (init_block_ptr))

	obtype = Vos_Define_Object_Prstate ("proc state vars (YAO_CTRL_UNIT)",
		sizeof (YAO_CTRL_UNIT_state));
	*init_block_ptr = 0;

	FRET (obtype)
	}

VosT_Address
_op_YAO_CTRL_UNIT_alloc (VosT_Obtype obtype, int init_block)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	YAO_CTRL_UNIT_state * ptr;
	FIN_MT (_op_YAO_CTRL_UNIT_alloc (obtype))

	ptr = (YAO_CTRL_UNIT_state *)Vos_Alloc_Object (obtype);
	if (ptr != OPC_NIL)
		{
		ptr->_op_current_block = init_block;
#if defined (OPD_ALLOW_ODB)
		ptr->_op_current_state = "YAO_CTRL_UNIT [init enter execs]";
#endif
		}
	FRET ((VosT_Address)ptr)
	}



void
_op_YAO_CTRL_UNIT_svar (void * gen_ptr, const char * var_name, void ** var_p_ptr)
	{
	YAO_CTRL_UNIT_state		*prs_ptr;

	FIN_MT (_op_YAO_CTRL_UNIT_svar (gen_ptr, var_name, var_p_ptr))

	if (var_name == OPC_NIL)
		{
		*var_p_ptr = (void *)OPC_NIL;
		FOUT
		}
	prs_ptr = (YAO_CTRL_UNIT_state *)gen_ptr;

	if (strcmp ("my_objid" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_objid);
		FOUT
		}
	if (strcmp ("my_node_id" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_node_id);
		FOUT
		}
	if (strcmp ("dataPlane_objid" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->dataPlane_objid);
		FOUT
		}
	if (strcmp ("neighbour_list" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->neighbour_list);
		FOUT
		}
	if (strcmp ("nexthopCategory_list" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->nexthopCategory_list);
		FOUT
		}
	if (strcmp ("C2PME_list" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->C2PME_list);
		FOUT
		}
	if (strcmp ("port_list" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->port_list);
		FOUT
		}
	if (strcmp ("conditionField_list" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->conditionField_list);
		FOUT
		}
	if (strcmp ("my_node_addr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_node_addr);
		FOUT
		}
	if (strcmp ("seq_num" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->seq_num);
		FOUT
		}
	if (strcmp ("ctrl_ete_delay_global" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ctrl_ete_delay_global);
		FOUT
		}
	if (strcmp ("neighbour_maintainance_list" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->neighbour_maintainance_list);
		FOUT
		}
	if (strcmp ("pkt4SR_list" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->pkt4SR_list);
		FOUT
		}
	if (strcmp ("sink_hello_num" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->sink_hello_num);
		FOUT
		}
	if (strcmp ("num_absorb_node" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->num_absorb_node);
		FOUT
		}
	if (strcmp ("sink_objid" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->sink_objid);
		FOUT
		}
	if (strcmp ("r_distance" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->r_distance);
		FOUT
		}
	if (strcmp ("successrate" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->successrate);
		FOUT
		}
	if (strcmp ("recv_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->recv_time);
		FOUT
		}
	if (strcmp ("userighthand" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->userighthand);
		FOUT
		}
	if (strcmp ("dist_neigh_to_sour" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->dist_neigh_to_sour);
		FOUT
		}
	if (strcmp ("no_seq" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->no_seq);
		FOUT
		}
	*var_p_ptr = (void *)OPC_NIL;

	FOUT
	}

